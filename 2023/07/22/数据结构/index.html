<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构 | Hexo</title><meta name="author" content="Oreges"><meta name="copyright" content="Oreges"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="绪论基本概念 数据： 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。 数据元素、数据项： 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据结构、数据对象： 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 数据">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://example.com/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="绪论基本概念 数据： 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。 数据元素、数据项： 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。 一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。 数据结构、数据对象： 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 数据">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-07-22T12:57:50.000Z">
<meta property="article:modified_time" content="2023-07-24T01:33:46.528Z">
<meta property="article:author" content="Oreges">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-24 09:33:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hexo"><span class="site-name">Hexo</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-22T12:57:50.000Z" title="发表于 2023-07-22 20:57:50">2023-07-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-24T01:33:46.528Z" title="更新于 2023-07-24 09:33:46">2023-07-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230724085024020.png" alt="image-20230724085024020"></p>
<p><em>数据</em>： <em>数据是信息的载体</em>，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的<em>符号的集合</em>。数据是计算机程序加工的原料。</p>
<p><em>数据元素、数据项</em>： 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。 一个数据元素可由若干数据项组成，<em>数据项是构成数据元素的不可分割的最小单位。</em></p>
<p><em>数据结构、数据对象</em>： 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。 <em>数据对象</em>是具有相同性质的<em>数据元素的集合</em>，是<em>数据的一个子集</em>。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230724085712842.png" alt="image-20230724085712842"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230724085838445.png" alt="image-20230724085838445"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230724085806958.png" alt="image-20230724085806958"></p>
<blockquote>
<ol>
<li>顺序存储。把逻辑上相邻的元素存储在物理位置 上也相邻的存储单元中，元素之间的关系由存储 单元的邻接关系来体现。</li>
<li>链式存储。逻辑上相邻的元素在物理位置上可以 不相邻，借助指示元素存储地址的指针来表示元 素之间的逻辑关系。</li>
<li>索引存储。在存储元素信息的同时，还建立附加 的索引表。索引表中的每项称为索引项，索引项 的一般形式是（关键字，地址）</li>
<li>散列存储。根据元素的关键字直接计算出该元素 的存储地址，又称哈希（Hash）存储</li>
</ol>
</blockquote>
<p>绪论部分只需要理解两点： </p>
<ol>
<li><p>若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用 非顺序存储，则各个数据元素在物理上可以是离散的。 </p>
</li>
<li><p>数据的存储结构会影响存储空间分配的方便程度 3.数据的存储结构会影响对数据运算的速度</p>
</li>
</ol>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义和基本操作"><a href="#线性表的定义和基本操作" class="headerlink" title="线性表的定义和基本操作"></a>线性表的定义和基本操作</h2><p>定义：n（n&gt;&#x3D;0）个相同数据类型的数据元素构成的有限序列，n&#x3D;0时，线性表为空表。线性表用L一般表示为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = (a1,a2,a3....,ai<span class="number">-1</span>,ai....,an)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>几个概念:<br>ai是线性表中的“第i个”元素线性表中的&#x3D;&#x3D;位序&#x3D;&#x3D; 注意:位序从1开始，数组下标从0开始<br>a1是&#x3D;&#x3D;表头元素&#x3D;&#x3D;; an 是&#x3D;&#x3D;表尾元素&#x3D;&#x3D;。</p>
<p>除第一个元素外，每个元素有且仅有一个&#x3D;&#x3D;直接前驱&#x3D;&#x3D;:除最后一个元素外，每个元素有且仅有一个&#x3D;&#x3D;直接后继&#x3D;&#x3D;</p>
</blockquote>
<p>InitList(&amp;L):初始化表。构造一个空的线性表L，分配内存空间。</p>
<p>DestroyList(&amp;():&#x3D;&#x3D;销毁操作&#x3D;&#x3D;。销毁线性表，并释放线性表L所占用的内存空间。</p>
<p>Listnsert(&amp;L,e):&#x3D;&#x3D;插入操作&#x3D;&#x3D;。在表L中的第1个位置上插入指定元素e.</p>
<p>ListDelete(&amp;L,&amp;e):&#x3D;&#x3D;删除操作&#x3D;&#x3D;。删除表l中第1个位置的元素，并用e返回删除元素的值。</p>
<p>LocateElem(L,e):&#x3D;&#x3D;按值查找操作&#x3D;&#x3D;。在表L中查找具有给定关键字值的元素。</p>
<p>GetElem(Lj):&#x3D;&#x3D;按位查找操作&#x3D;&#x3D;。获取表L中第i个位置的元素的值。其他常用操作:</p>
<p>Length(U:求表长。返回线性表L的长度，即L中数据元素的个数。</p>
<p>PrintList(L):输出操作。按前后顺序输出线性表L的所有元素值。.</p>
<p>Empty(L):判空操作。若L为空表，则返回true，否则返回false.</p>
<blockquote>
<p>Tips:<br>①对数据的操作(记忆思路) –创销、增删改查</p>
<p>②C语言函数的定义– &lt;返回值类型&gt; 函数名(&lt;参数1类型&gt;参数1，&lt;参数2类型&gt;参数2，…)</p>
<p>③实际开发中，可根据实际需求定义其他的基本操作</p>
<p>④函数名和参数的形式、命名都可改变(Reference: 严蔚敏版《数据结构》Key:命名要有可读性</p>
<p>⑤什么时候要传入参数的引用“&amp;”–对参数的修改结果需要“带回来”</p>
</blockquote>
<p><em><strong>线性表是一种逻辑结构，顺序表和链表是存储结构</strong></em></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230225115650652.png" alt="image-20230225115650652"></p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="顺序表的定义"><a href="#顺序表的定义" class="headerlink" title="顺序表的定义"></a>顺序表的定义</h3><p>线性表是具有相同数据类型的n（n&gt;&#x3D;0） 个&#x3D;&#x3D;数据元素&#x3D;&#x3D;的有限序列</p>
<p>线性表L的逻辑结构</p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230225112917340.png" alt="image-20230225112917340" style="zoom: 80%;">

<blockquote>
<p>线性表的存储结构：<code>顺序表</code>——即在逻辑结构上相邻，在物理（存储）结构上也相邻</p>
</blockquote>
<p>顺序表——用顺序存储的方式实现线性表顺序存储。把&#x3D;&#x3D;逻辑上相邻&#x3D;&#x3D;的元素存储在&#x3D;&#x3D;物理位置上也相邻&#x3D;&#x3D;的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p>
<p><strong>顺序表的实现——静态分配</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10  			<span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">//ElemType是需要给定的数据类型</span></span><br><span class="line">	ElemType data [MaxSize] ;	<span class="comment">//用静态的“数组”存放数据元素.</span></span><br><span class="line">	<span class="type">int</span> length;					<span class="comment">//顺序表的当前长度.</span></span><br><span class="line">&#125;SqList;						<span class="comment">//顺序表的类型定义(静态分配方式)</span></span><br></pre></td></tr></table></figure>

<p>eg:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stido.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10  			<span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> data [MaxSize] ;	<span class="comment">//用静态的“数组”存放数据元素.</span></span><br><span class="line">	<span class="type">int</span> length;					<span class="comment">//顺序表的当前长度.</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SqLsit &amp;L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">        L.data[i] = <span class="number">0</span>;		<span class="comment">//若不赋值，不能保障之前内存是否留存“脏数据”</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SqList L; 		<span class="comment">//声明一个顺序表</span></span><br><span class="line">	<span class="built_in">InitList</span>(L);	<span class="comment">//初始化顺序表</span></span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态分配会存在数据存满后就不能存的情况</p>
</blockquote>
<p><strong>顺序表的实现——动态分配</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10 <span class="comment">//顺序表的初始长度.</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ELemType *data;		<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize;		<span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length;			<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125; SeqList;			<span class="comment">//顺序表的类型定义(动态分配方式)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>动态申请和释放空间</p>
<p>C——malloc、free函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*InitSize)</span><br></pre></td></tr></table></figure>

<p>C++——new、delete</p>
</blockquote>
<p>eg：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10 	<span class="comment">//默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">int</span> *data;			<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize;		<span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length;			<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SeqList;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitList</span><span class="params">(SeqList &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用mal1oc 函数申请一片连续的存储空间</span></span><br><span class="line">    L.data=(<span class="type">int</span> * )<span class="built_in">malloc</span>(InitSize*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    L.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">IncreaseSize</span><span class="params">(SeqList &amp;L, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p=L.data; <span class="comment">//让p指向原区域</span></span><br><span class="line">    L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len)*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;L.length; i++)&#123;</span><br><span class="line">    	L.data[i]=p[i];			<span class="comment">//将数据复制到新区域：时间开销大</span></span><br><span class="line">	&#125;</span><br><span class="line">    L.MaxSize=L.MaxSize+len;	<span class="comment">//顺序表最大长度增加len</span></span><br><span class="line">    <span class="built_in">free</span>(p);	<span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	SeqList L;</span><br><span class="line">	<span class="built_in">InitList</span>(L);</span><br><span class="line">    <span class="comment">//....往顺序表中插入几个元素</span></span><br><span class="line">    <span class="built_in">IncreaseSize</span>(L,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>顺序表的特点:</p>
<p>①&#x3D;&#x3D;随机访问&#x3D;&#x3D;，即可以在O(1)时间内找到第i个元素。代码实现: data[i-1];静态分配、动态分配都一样</p>
<p>②&#x3D;&#x3D;存储密度高&#x3D;&#x3D;，每个节点只存储数据元素</p>
<p>③拓展容量不方便(即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高)</p>
<p>④插入、删除操作不方便，需要移动大量元素</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230225121818844.png" alt="image-20230225121818844"></p>
<h3 id="顺序表的基本操作"><a href="#顺序表的基本操作" class="headerlink" title="顺序表的基本操作"></a>顺序表的基本操作</h3><h4 id="顺序表的插入和删除"><a href="#顺序表的插入和删除" class="headerlink" title="顺序表的插入和删除"></a>顺序表的插入和删除</h4><p><strong>顺序表的基本操作——插入</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230227121306544.png" alt="image-20230227121306544"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span></span>&#123;	<span class="comment">//在L的位序i处插入元素e</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = L.length;j&gt;i;j--)	<span class="comment">//所有i后面的元素往后移一位</span></span><br><span class="line">        L.data[j] = L.data[j<span class="number">-1</span>]</span><br><span class="line">    L.data[i<span class="number">-1</span>] = e;				<span class="comment">//位序i，对应数组i-1</span></span><br><span class="line">    L.length++;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>优化代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>)		<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length&gt;=MaxSize)    	<span class="comment">//当前存储空间已满，不能插入</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--) <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">    	L.data[j]=L.data[j<span class="number">-1</span>];</span><br><span class="line">    L.data[i<span class="number">-1</span>]=e;    <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++;    <span class="comment">//长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>好的算法，应该具有“健壮性”。能处理异常情况，并给使用者反馈</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230227122331583.png" alt="image-20230227122331583"></p>
<p><strong>顺序表的基本操作——删除</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230227122503808.png" alt="image-20230227122503808"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length)		<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> flase;</span><br><span class="line">    e = L.data[i<span class="number">-1</span>];			<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=L.length;j&gt;=i;j--) <span class="comment">//将第i个元素及之后的元素前移</span></span><br><span class="line">    	L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">    L.length--;    <span class="comment">//长度减1</span></span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230227122925343.png" alt="image-20230227122925343"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230227122956305.png" alt="image-20230227122956305"></p>
<h4 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h4><p><strong>顺序表按位查找</strong></p>
<p>GetElem(L,i):按位查找操作。获取表L中第i个位置的元素的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10 				<span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data [MaxSize] ;	<span class="comment">//用静态的“数组”存放数据元素（静态分配）</span></span><br><span class="line">    <span class="type">int</span> length;					<span class="comment">//顺序表的当前长度:</span></span><br><span class="line">&#125;SqList;						<span class="comment">//顺序表的类型定义(静态分配方式)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElemType <span class="title">GetElem</span><span class="params">(SqList L，<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetElem(L,i):按位查找操作。获取表L中第i个位置的元素的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10 <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType *data;		<span class="comment">//指示动态分配数组的指针 动态分配</span></span><br><span class="line">    <span class="type">int</span> MaxSize;		<span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length;			<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125; SeqList;				<span class="comment">//顺序表的类型定义(动态分配方式)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(1)</p>
<p>由于顺序表的各个数据元素在内存中连续存放，因此可以根据起始地址和数据元素大小立即找到第i个元素——“随机存取”特性</p>
</blockquote>
<p><strong>顺序表按值查找</strong></p>
<p>LocateElem(,e):按值查找操作。在表L中查找具有给定关键字值的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>. InitSize 10<span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType *data;	<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize;	<span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length;		<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125; SeqList;		<span class="comment">//顺序表的类型定义(动态分配方式)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在顺序表L中查找第一个元素值等于e的元素，并返回其位序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SeqList L, ElemType e)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length; i++)</span><br><span class="line">    <span class="keyword">if</span>(L.data[i]==e)</span><br><span class="line">    	<span class="keyword">return</span> i+<span class="number">1</span>; 	<span class="comment">//数组下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    		<span class="comment">//退出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基本数据类型: int、 char、 double、float等可以直接用运算符“&#x3D;&#x3D;”比较</p>
<p>对于结构体的比较：</p>
<p>需要依次对比各个分量来判断两个结构体是否相等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line"> <span class="type">int</span> num;</span><br><span class="line"> <span class="type">int</span> people; </span><br><span class="line">&#125; Customer;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a.num ==: b.num &amp;&amp; a.people == b.people) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;相等&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;不相等&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230227124809274.png" alt="image-20230227124809274"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230227124822828.png" alt="image-20230227124822828"></p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><p>单链表和顺序表的区别</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230227125359374.png" alt="image-20230227125359374"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;			<span class="comment">//结点</span></span><br><span class="line">	ElemType data;		<span class="comment">//数据域</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span>* p;	<span class="comment">//指针域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加一个新的结点:在内存中申请一个结点所需空间，并用指针p指向这个结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span>* p= (<span class="keyword">struct</span> LNode* )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>typedef关键字一一数据类型重命名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> &lt;数据类型&gt; &lt;别名&gt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> LNode;</span><br><span class="line">LNode *p= (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br></pre></td></tr></table></figure>
</blockquote>
<p>代码优化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123; 	<span class="comment">//定义单链表结点类型</span></span><br><span class="line">    ElemType data;			<span class="comment">//每个节点存放- -个数据元素</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next ;	<span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode, *LinkList; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>LNode *p和 LNode L都表示指向结构体的指针</p>
<p>LNode *p 一般表示节点的指针</p>
<p>LNode L 头指针，一般用来表示一个链表</p>
</blockquote>
<h3 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h3><p><strong>不带头结点的单链表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = <span class="literal">NULL</span>;			<span class="comment">//空表暂时没有任何节点（防止脏数据）</span></span><br><span class="line">	<span class="keyword">return</span> ture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LinkList L;		<span class="comment">//注意，此处并没有创建个结点</span></span><br><span class="line">	<span class="built_in">InitList</span>(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (L==<span class="literal">NULL</span>); .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>带头结点的单链表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化-个单链表(带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L==<span class="literal">NULL</span>) <span class="comment">//内存不足， 分配失败</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//头结点之后暂时还没有节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断单链表是否为空(带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不带头结点，写代码更麻烦。对第一个数据结点和后续数据结点的处理需要用不同的代码逻辑。对空表和非空表的处理需要用不同的代码逻辑</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230227131922545.png" alt="image-20230227131922545"></p>
<h3 id="单链表的基本操作"><a href="#单链表的基本操作" class="headerlink" title="单链表的基本操作"></a>单链表的基本操作</h3><h4 id="单链表的插入和删除"><a href="#单链表的插入和删除" class="headerlink" title="单链表的插入和删除"></a>单链表的插入和删除</h4><p><strong>按位序插入（带头结点）</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230227132229110.png" alt="image-20230227132229110"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在第i个位置插插入元素e (带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p; 	<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;     <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;	    <span class="comment">//L指向头结点，头结点是第0个结点(不存数据)</span></span><br><span class="line">    <span class="keyword">while</span> (p!= <span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>) &#123; <span class="comment">//循环找到第 i-1个结点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) 	<span class="comment">//i值不合法</span></span><br><span class="line">   		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next=p-&gt;next;	<span class="comment">//跟下一句有先后关系</span></span><br><span class="line">	p-&gt;next=s;    <span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//插入成功.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>i &#x3D; 1（插在表头） 最好时间复杂度：O(1)</p>
<p>i &#x3D; n （插在表尾）最坏时间复杂度：O(n)</p>
<p>平均时间复杂度:O(n)</p>
</blockquote>
<p><strong>按位序插入（不带头结点）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;	<span class="comment">//插入第1个结点的操作与其他结点操作不同</span></span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span> (<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        S-&gt;next=L ;</span><br><span class="line">        L=s;        <span class="comment">// 头指针指向新结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>; <span class="comment">//当前p指向的是第几个结点!</span></span><br><span class="line">    p=L 	<span class="comment">//p指问第1个结点(注意:不是头结点)</span></span><br><span class="line">    <span class="comment">//下面和带头节点逻辑一样</span></span><br><span class="line">    <span class="keyword">while</span> (p!= <span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>) &#123; <span class="comment">//循环找到第 i-1个结点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) 	<span class="comment">//i值不合法</span></span><br><span class="line">   		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next=p-&gt;next;	<span class="comment">//跟下一句有先后关系</span></span><br><span class="line">	p-&gt;next=s;    <span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//插入成功.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>指定结点的后插操作</strong></p>
<blockquote>
<p>相当于按位序插入中查找步骤完成</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LNode *p,  ElemType e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p==<span class="literal">NULL</span>) 	<span class="comment">//i值不合法</span></span><br><span class="line">   		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next=p-&gt;next;	<span class="comment">//跟下一句有先后关系</span></span><br><span class="line">	p-&gt;next=s;    <span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//插入成功.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(1)</p>
</blockquote>
<p><strong>指定结点的前插操作</strong></p>
<p>1.循环查找p的前驱q，再对q后插<br>时间复杂度：O(n)</p>
<p>2.数据替换法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插操作:在p结点之前插入元素e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertPriorNode</span> <span class="params">(LNode *p, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *S = (LNode * )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">NULL</span>) <span class="comment">//内存分配失败</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next= p-&gt;next ;</span><br><span class="line">    p-&gt;next=s;    		<span class="comment">//新结点s连到p之后</span></span><br><span class="line">    s-&gt;data=p-&gt;data;    <span class="comment">//将p中元素复制到s中</span></span><br><span class="line">    p-&gt;data=e;		    <span class="comment">//p中元素覆盖为e</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(1)</p>
</blockquote>
<p><strong>按位序删除（带头结点）</strong></p>
<p>ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第&#x3D;&#x3D;i个位置&#x3D;&#x3D;的元素，并用e返回删除元素的值。</p>
<p>找到第 i-1 个结点，将其指针指向第i+1个结点， 并释放第i个结点</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230227135334104.png" alt="image-20230227135334104"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L，<span class="type">int</span> i, ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p; 	<span class="comment">// 指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;    <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p=L;    	<span class="comment">//L指向头结点，头结点是第0个结点(不存数据)</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>) &#123; <span class="comment">//循环找到第 i-1 个结点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( p==<span class="literal">NULL</span>)    <span class="comment">//i值不合法</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)    <span class="comment">//第i-1个结点之后已无其他结点</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q=p-&gt;next;    	<span class="comment">//令q指向被删除结点</span></span><br><span class="line">    e = q-&gt;data;    		<span class="comment">//用e返回元素的值</span></span><br><span class="line">    p-&gt;next=q-&gt;next;	    <span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q);			    <span class="comment">//释放结点的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;		    <span class="comment">//删除成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>i &#x3D; 1（删除在表头） 最好时间复杂度：O(1)</p>
<p>i &#x3D; n （删除在表尾）最坏时间复杂度：O(n)</p>
<p>平均时间复杂度:O(n)</p>
</blockquote>
<p><strong>指定结点的删除</strong></p>
<p>找到其后继节点，将后继节点数据转到当前节点，删除后继节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( p==<span class="literal">NULL</span>)    <span class="comment">//i值不合法</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     LNode *q=p-&gt;next;    	<span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data;<span class="comment">//和后继节点交换数据</span></span><br><span class="line">    p-&gt;next = q-&gt;next;	    <span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q);			    <span class="comment">//释放结点的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;		    <span class="comment">//删除成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>如果p是最后一个节点，则只能从表头开始依次寻找p的前驱，时间复杂度O(n)</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301104810455.png" alt="image-20230301104810455"></p>
<h4 id="单链表的查找"><a href="#单链表的查找" class="headerlink" title="单链表的查找"></a>单链表的查找</h4><p><strong>按位查找</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找，返回第i个元素(带头结点)</span></span><br><span class="line"><span class="function">LNode * <span class="title">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p; 	<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;    <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p=L;    	<span class="comment">//L指向头结点，头结点是第0个结点(不存数据)</span></span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i) &#123; <span class="comment">//循环找到第 i个结点</span></span><br><span class="line">        p=p- &gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>平均时间复杂度：O(n)</p>
</blockquote>
<p><strong>按值查找</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据域= =e的结点</span></span><br><span class="line"><span class="function">LNode * <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    LNode *p = L- &gt;next;    </span><br><span class="line">    <span class="comment">//从第1个结 点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e)</span><br><span class="line">    	p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p; 	<span class="comment">//找到后返回该结点指针， 否则返回NULL  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>平均时间复杂度：O(n)</p>
</blockquote>
<p><strong>求表的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求表的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>; <span class="comment">//统计表长</span></span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        len++; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(n)</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301110518192.png" alt="image-20230301110518192"></p>
<h3 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h3><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><p><strong>尾插法建立单链表原理</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在第i个位置插插入元素e (带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p; 	<span class="comment">//指针p指向当 前扫描到的结点</span></span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;     <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;	    <span class="comment">//L指向头结点，头结点是第0个结点(不存数据)</span></span><br><span class="line">    <span class="keyword">while</span> (p!= <span class="literal">NULL</span> &amp;&amp; j&lt;i<span class="number">-1</span>) &#123; <span class="comment">//循环找到第 i-1个结点</span></span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) 	<span class="comment">//i值不合法</span></span><br><span class="line">   		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next=p-&gt;next;	<span class="comment">//跟下一句有先后关系</span></span><br><span class="line">	p-&gt;next=s;    <span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//插入成功.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>尾插法建立链表实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_Taillinsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x;	<span class="comment">//设置Element的类型为整型</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode))	<span class="comment">//建立头节点，初始化空表 </span></span><br><span class="line">    LNode *s,*r = L;	<span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x); 	<span class="comment">//输入节点值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;		<span class="comment">//输入9999表示结束、</span></span><br><span class="line">        s = (LNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;			<span class="comment">//r指向新的尾表节点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;		<span class="comment">//尾指针置为空</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(n)</p>
</blockquote>
<h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><p><strong>头插法建立单链表原理</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后插操作:在p结点之后插入元素e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextNode</span> <span class="params">(LNode *p，ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span> (<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">NULL</span>) 	<span class="comment">//内存分配失败</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;    <span class="comment">//用结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;    	<span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每次都对头节点进行后插操作</p>
</blockquote>
<p><strong>头插法建立单链表实现：相当于每次新结点都是作为第一个结点</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList List_ <span class="title">HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123; <span class="comment">//逆向建立单链表</span></span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="type">int</span> x; .</span><br><span class="line">    L=(LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); 	<span class="comment">// 创建头结点</span></span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;						<span class="comment">//初始为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);					    <span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;					    <span class="comment">//输入9999表示结束</span></span><br><span class="line">        s=(LNode* )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); 	<span class="comment">//创建新结点</span></span><br><span class="line">        s-&gt;data=X;</span><br><span class="line">        s-&gt;next=L-&gt; next;</span><br><span class="line">        L-&gt;next=S; 			    <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> ,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>不能去除，在尾插法中可以去掉，但是还是建议都加上</p>
</blockquote>
<blockquote>
<p>头插法建立单链的重要应用：&#x3D;&#x3D;链表的逆置&#x3D;&#x3D;</p>
</blockquote>
<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p><strong>双链表和单链表的区别</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301121116220.png" alt="image-20230301121116220"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">DNode</span>&#123;		<span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ElemType data;				<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">DNode</span> *prior, *next;	<span class="comment">//前驱和后继指针</span></span><br><span class="line">&#125;DNode，*DLinklist;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相比于单链表，双链表访问前后相邻节点跟方便，同时其存储密度也更低一点</p>
</blockquote>
<h3 id="双链表的初始化"><a href="#双链表的初始化" class="headerlink" title="双链表的初始化"></a>双链表的初始化</h3><p><strong>双链表的初始化（带头结点）</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化双链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinklist &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(DNode)); <span class="comment">//分配-个头结点</span></span><br><span class="line">    	<span class="keyword">if</span> (L==<span class="literal">NULL</span>) 		<span class="comment">//内存不足， 分配失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;    <span class="comment">//头结点的prior永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>:    <span class="comment">//头结点之后暂时还没有节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断双链表是否为空(带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(DLinklist L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>双链表的插入</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301121829792.png" alt="image-20230301121829792"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301122351222.png" alt="image-20230301122351222"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p=<span class="literal">NULL</span> || s=<span class="literal">NULL</span>) <span class="comment">//非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next=p-&gt;next;<span class="comment">//将结点*s插入到结点*p之后</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next-&gt;prior!=<span class="literal">NULL</span>) <span class="comment">//为了防止p是最后一个节点</span></span><br><span class="line">	    p-&gt;next-&gt;prior=s;</span><br><span class="line">    s-&gt;prior=p;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位序插入：先遍历，找到对应位序的前一个节点，进行后插操作（O(n)）</p>
<p>前插操作：找到对应节点的前一个节点，进行后插操作（O(1)）</p>
</blockquote>
<h3 id="双链表的删除"><a href="#双链表的删除" class="headerlink" title="双链表的删除"></a>双链表的删除</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301123238921.png" alt="image-20230301123238921"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DNode *q = p-&gt;next; <span class="comment">//找到p的后继结点q</span></span><br><span class="line">    <span class="keyword">if</span> (q==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; 	<span class="comment">//p没有后继</span></span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;next !=<span class="literal">NULL</span>) <span class="comment">//q结点不是最后- 个结点</span></span><br><span class="line">        q-&gt;next-&gt;prior=p;</span><br><span class="line">    <span class="built_in">free</span>(q);		    <span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestoryList</span><span class="params">(DLinklist &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">    <span class="keyword">while</span> (L-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">DeleteNextDNode</span>(L); <span class="comment">//上面定义的方法</span></span><br><span class="line">    <span class="built_in">free</span>(L); <span class="comment">//释放头结点</span></span><br><span class="line">    L=<span class="literal">NULL</span>; <span class="comment">//头指针指向NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表的遍历"><a href="#双链表的遍历" class="headerlink" title="双链表的遍历"></a>双链表的遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后向遍历</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//....对节点p的相关操作</span></span><br><span class="line">	p = p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前向遍历</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//....对节点p的相关操作</span></span><br><span class="line">	p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前向遍历（跳过头节点）</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;prior!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//....对节点p的相关操作</span></span><br><span class="line">	p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>双链表不可随机存取，按位查找、按值查找操作都只能用遍历的方式实现。时间复杂度O(n)</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301124109230.png" alt="image-20230301124109230"></p>
<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301124347370.png" alt="image-20230301124347370"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>&#123;	<span class="comment">//定义单链表结点类型</span></span><br><span class="line">    ElemType data;		<span class="comment">//每个节点存放-个数据元素</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;	<span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode, *LinkList;		<span class="comment">//初始化一 个循环单链表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode)); <span class="comment">//分配-个头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L==<span class="literal">NULL</span>)	 <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = L;	<span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next ==L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTail</span><span class="params">(LinkList L，LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next==L)]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>单链表：从一个结点出发只能找到后续的各个结点</p>
<p>循环单链表：从一个结点出发可以找到其他任何一个结点</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301125202282.png" alt="image-20230301125202282"></p>
<blockquote>
<p>&#x3D;&#x3D;常对链表的头部或尾部进行操作时&#x3D;&#x3D;，可以让L指向表尾元素(插入、删除时可能需要修改)，即&#x3D;&#x3D;用一个不带头结点且有尾指针的单循环链表&#x3D;&#x3D;</p>
</blockquote>
<h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301125614926.png" alt="image-20230301125614926"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化空的循环双链表</span></span><br><span class="line"><span class="function"><span class="type">bool</span> InitDLinkL <span class="title">ist</span> <span class="params">(DLinklist &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (DNode)); <span class="comment">//分配-个头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L==<span class="literal">NULL</span>) 	<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = L;	<span class="comment">//头结点的prior指向头结点（特性：prior指向尾节点）</span></span><br><span class="line">    L-&gt;next = L;	<span class="comment">//头结点的next 指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断循环双链表是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Emptv</span><span class="params">(DL inklist L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next ==L）</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isTail</span><span class="params">(DLinklist L, DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span></span><br><span class="line">        (p-&gt;next==L)|</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    eLse</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环双链表插入</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301130211775.png" alt="image-20230301130211775"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextDNode</span> <span class="params">(DNode *p, DNode *s)</span></span>&#123;</span><br><span class="line">    s-&gt;next=p-&gt;next; <span class="comment">//将结点*s插入到结点和之后</span></span><br><span class="line">    p-&gt;next-&gt;prior=s; <span class="comment">//普通双链表在此处需判断p是否尾节点</span></span><br><span class="line">    s-&gt;prior=p;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>循环双链表的删除</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301130536950.png" alt="image-20230301130536950"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从删除p的后继结点q</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior=p;	<span class="comment">//普通双链表在此处需判断p是否尾节点</span></span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301130722976.png" alt="image-20230301130722976"></p>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><h3 id="静态链表定义"><a href="#静态链表定义" class="headerlink" title="静态链表定义"></a>静态链表定义</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301131050342.png" alt="image-20230301131050342"></p>
<p>单链表：各个结点在内存中星罗棋布、散落天涯。 </p>
<p>静态链表：分配一整片连续的内存空间，各个结点集中安置。 每个数据元素 4B，每个游标4B（每个结点共 8B） 设起始地址为 addre</p>
<p><strong>定义一个静态链表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;		<span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;	<span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;		<span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> testSLinkL <span class="title">ist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> a[MaxSize]; <span class="comment">//数组a作为静态链表</span></span><br><span class="line">    <span class="comment">//......后续代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;	<span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">    ElemType data;	<span class="comment">//存储数据元素</span></span><br><span class="line">    <span class="type">int</span> next;	<span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125; SLinkList[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testSLinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SLinkList a;</span><br><span class="line">    <span class="comment">//.....后续代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在代码阅读感知方面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a是一个Node型数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> a[MaxSize]; <span class="comment">//数组a作为静态链表</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a是一个静态链表</span></span><br><span class="line">SLinkList a;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="基本操作实现"><a href="#基本操作实现" class="headerlink" title="基本操作实现"></a>基本操作实现</h3><ol>
<li>初始化静态链表： 把 a[0] 的 next 设为 -1 把其他结点的 next 设为一个特殊值用来表示结点空闲，如 -2</li>
<li>查找： 从头结点出发挨个往后遍历结点 （O(n)）</li>
<li>插入位序为 i 的结点： <ol>
<li>找到一个空的结点，存入数据元素 </li>
<li>从头结点出发找到位序为 i-1 的结点 </li>
<li>修改新结点的 next </li>
<li>修改 i-1 号结点的 next</li>
</ol>
</li>
<li>删除某个结点： <ol>
<li>从头结点出发找到前驱结点 </li>
<li>修改前驱结点的游标 </li>
<li>被删除结点 next 设为 特殊值（如-2）</li>
</ol>
</li>
</ol>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301133214462.png" alt="image-20230301133214462"></p>
<h2 id="顺序表vs链表"><a href="#顺序表vs链表" class="headerlink" title="顺序表vs链表"></a>顺序表vs链表</h2><table>
<thead>
<tr>
<th>特性</th>
<th>顺序表</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>逻辑结构</td>
<td>线性结构</td>
<td>线性结构</td>
</tr>
<tr>
<td>存储结构</td>
<td>顺序存储</td>
<td>链式存储</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>存储结构：</strong></p>
<p>顺序存储：</p>
<ol>
<li>优点：支持随机存取、&#x3D;&#x3D;存储密度高&#x3D;&#x3D; </li>
<li>缺点：&#x3D;&#x3D;大片连续空间分配不方便&#x3D;&#x3D;，改变容量不方便</li>
</ol>
<p>链式存储：</p>
<ol>
<li>优点：离散的小&#x3D;&#x3D;空间分配方便&#x3D;&#x3D;，改变容量方便</li>
<li>缺点：不可随机存取，&#x3D;&#x3D;存储密度低&#x3D;&#x3D;</li>
</ol>
</blockquote>
<p><strong>基本操作比较</strong></p>
<p><strong>创建</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301134201242.png" alt="image-20230301134201242"></p>
<p><strong>销毁</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301134317227.png" alt="image-20230301134317227"></p>
<p><strong>增、删</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301134449970.png" alt="image-20230301134449970"></p>
<p><strong>查找</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301134526506.png" alt="image-20230301134526506"></p>
<p><strong>基于基本操作，选取上的优先级</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>顺序表</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>弹性（可扩容）</td>
<td>✗</td>
<td>✔</td>
</tr>
<tr>
<td>增、删</td>
<td>✗</td>
<td>✔</td>
</tr>
<tr>
<td>查</td>
<td>✔</td>
<td>✗</td>
</tr>
</tbody></table>
<blockquote>
<p>表长难以预估、经常要增加&#x2F;删除元素 ——链表 </p>
<p>表长可预估、查询（搜索）操作较多 ——顺序表</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230301135341470.png" alt="image-20230301135341470"></p>
<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h3><p>栈的定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限 序列，其中n为表长，当n &#x3D; 0时线 性表是一个空表。若用L命名线性表，则其一般表示为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L = (a1, a2, … , ai, ai+<span class="number">1</span>, … , an)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>栈（Stack）是只&#x3D;&#x3D;允许在一端进行插入或删除&#x3D;&#x3D;操作的&#x3D;&#x3D;线性表&#x3D;&#x3D;</p>
<ol>
<li>逻辑结构：与普通线性表相同 </li>
<li>数据的运算：插入、删除操作有区别</li>
</ol>
</blockquote>
<p>栈顶：允许插入和删除的一端</p>
<p>栈底：不允许插入和删除的一端</p>
<blockquote>
<p>特点：后进先出 Last In First Out （LIFO）</p>
</blockquote>
<p><strong>栈的基本操作</strong></p>
<p>InitStack(&amp;S)：初始化栈。构造一个空栈 S，分配内存空间。 </p>
<p>DestroyStack(&amp;S)：销毁栈。销毁并释放栈 S 所占用的内存空间。 </p>
<p>Push(&amp;S,x)：进栈，若栈S未满，则将x加入使之成为新栈顶。 </p>
<p>Pop(&amp;S,&amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回。 </p>
<p>GetTop(S, &amp;x)：读栈顶元素。若栈 S 非空，则用 x 返回栈顶元素 </p>
<p>其他常用操作： StackEmpty(S)：判断一个栈 S 是否为空。若S为空，则返回true，否则返回false。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302104553996.png" alt="image-20230302104553996"></p>
<h3 id="顺序栈的实现"><a href="#顺序栈的实现" class="headerlink" title="顺序栈的实现"></a>顺序栈的实现</h3><p><strong>顺序栈的定义</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ELemType data[MaxSize] 	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure>

<p><strong>初始化操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	S.top=<span class="number">-1</span>;	<span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>栈空判断：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top== <span class="number">-1</span>)		<span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>				<span class="comment">//不空</span></span><br><span class="line">        <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进栈操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素进栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S , ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top=MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈满</span></span><br><span class="line">    &#125;</span><br><span class="line">    S.data[++S.top] = x; <span class="comment">//先加再存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出栈操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S , ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈空</span></span><br><span class="line">    &#125;</span><br><span class="line">    x = S.data[S.top--] ; <span class="comment">//先存再减</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读栈顶元素操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和出栈操作类似，但是指针不用移动</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S , ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top=<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//栈空</span></span><br><span class="line">    &#125;</span><br><span class="line">    x = S.data[S.top] ; <span class="comment">//只存栈顶元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>另一种方式</p>
<p>初始时让指针指向0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">	S.top= <span class="number">0</span>;	<span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则其进栈和出栈分别为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进栈</span></span><br><span class="line">S.data[S.top++] = x; <span class="comment">//先存再加</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈</span></span><br><span class="line">x = S.data[--S.top] ; <span class="comment">//先减再存</span></span><br></pre></td></tr></table></figure>

<p>其判空和栈满判断：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判空</span></span><br><span class="line">S.top == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈满</span></span><br><span class="line">S.top == MaxSize</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><p>共享栈：两个栈共享同一片空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10	<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data [MaxSize];	<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;	<span class="comment">//0号栈我顶指针</span></span><br><span class="line">    <span class="type">int</span> top1; 	<span class="comment">//11号栈线顶指针</span></span><br><span class="line">&#125; ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0=<span class="number">-1</span>;	<span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top1=MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>栈满条件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S.top0 + <span class="number">1</span> == S.top1</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302111736566.png" alt="image-20230302111736566"></p>
<h3 id="链栈的实现"><a href="#链栈的实现" class="headerlink" title="链栈的实现"></a>链栈的实现</h3><p>头插法建立单链表——对应：进栈</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后插操作:在p结点之后插入元素e</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">InsertNextNode</span> <span class="params">(LNode *p，ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span> (<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="literal">NULL</span>) 	<span class="comment">//内存分配失败</span></span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;    <span class="comment">//用结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p- &gt;next=s;    	<span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链栈的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Linknode</span>&#123;</span><br><span class="line">    ELemType data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Linknode</span> *next;	<span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;	<span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302113328514.png" alt="image-20230302113328514"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302113347586.png" alt="image-20230302113347586"></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h3><p>队列（Queue）是只允许在&#x3D;&#x3D;一端进行插入，在另一端删除&#x3D;&#x3D;的&#x3D;&#x3D;线性表&#x3D;&#x3D;</p>
<blockquote>
<p><code>特点：先进先出（FIFO）</code></p>
</blockquote>
<p><strong>队列的基本操作</strong></p>
<p>InitQueue(&amp;Q)：初始化队列，构造一个空队列Q。 </p>
<p>DestroyQueue(&amp;Q)：销毁队列。销毁并释放队列Q所占用的内存空间。 </p>
<p>EnQueue(&amp;Q,x)：入队，若队列Q未满，将x加入，使之成为新的队尾。 </p>
<p>DeQueue(&amp;Q,&amp;x)：出队，若队列Q非空，删除队头元素，并用x返回。 </p>
<p>GetHead(Q,&amp;x)：读队头元素，若队列Q非空，则将队头元素赋值给x。 </p>
<p>其他常用操作： QueueEmpty(Q)：判队列空，若队列Q为空返回true，否则返回false</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302200242058.png" alt="image-20230302200242058"></p>
<h3 id="队列的顺序实现"><a href="#队列的顺序实现" class="headerlink" title="队列的顺序实现"></a>队列的顺序实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> s Maxsize 10	<span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;			</span><br><span class="line">    ElemType data [MaxSize];	<span class="comment">//用静态数组存放队列元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;			<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure>

<h4 id="队尾指针指向队尾元素的后一个位置-（下一个应该插入的位置）"><a href="#队尾指针指向队尾元素的后一个位置-（下一个应该插入的位置）" class="headerlink" title="队尾指针指向队尾元素的后一个位置 （下一个应该插入的位置）"></a>队尾指针指向队尾元素的后一个位置 （下一个应该插入的位置）</h4><p><strong>队列初始化</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//初始化队列</span><br><span class="line">void InitQueue (SqQueue &amp;Q) &#123;</span><br><span class="line">    //初始时队头、队尾指针指向0</span><br><span class="line">    Q.rear=Q.front=0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>队列判空</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span> <span class="params">( SqQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)	<span class="comment">//队空条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>入队操作：&#x3D;&#x3D;只能从队尾入队（插入）&#x3D;&#x3D;</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (队列已满)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; 		<span class="comment">//队满则报错</span></span><br><span class="line">    Q.data[Q.rear]=x; 	<span class="comment">//将x插入队尾</span></span><br><span class="line">    Q. rear=(Q.rear+<span class="number">1</span>)%MaxSize;	<span class="comment">//队尾指针后移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出队操作：&#x3D;&#x3D;只能让队头元素出队&#x3D;&#x3D;</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队(删除一个队头元素， 并用x返回)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span> <span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)	<span class="comment">//判断队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; 	<span class="comment">//队空则报错</span></span><br><span class="line">    x=Q.data[Q.front];</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MaxSize</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取队头元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得队头元素的值，用x返回</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span> <span class="params">(SqQueue Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q. rear==Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//队空则报错</span></span><br><span class="line">    x=Q.data [Q.front] ;</span><br><span class="line">   		<span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意：队列已满的条件： rear&#x3D;&#x3D;MaxSize ??? </p>
<p><strong>队列需要循环利用，当尾指针移到尾部时，前面若是有出队后留下的空位，尾指针需要重新移到前面</strong>，固有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q. rear=(Q.rear+<span class="number">1</span>)%MaxSize;	<span class="comment">//队尾指针后移</span></span><br></pre></td></tr></table></figure>

<p>尾指针移动后对MaxSize取模操作</p>
</blockquote>
<p>&#x3D;&#x3D;队满的判断（3种情况）：&#x3D;&#x3D;</p>
<ol>
<li><p>牺牲一个内存单元 ：即尾指针指向最后一个空内存单元时（下一个就是队头），则就认为此时队满</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Q.rear + <span class="number">1</span>)%MaxSize == Q.front</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加<code>size</code>变量记录队列长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span> <span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.rear=Q.front=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">//队列当前长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入成功 size++； 删除成功 size–;    </p>
<p>队满条件： <code>size==MaxSize</code></p>
<p>队空条件：<code>size == 0</code> </p>
</li>
<li><p>增加<code>tag</code>变量记录当前操作的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span> <span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.rear=Q.front=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tag; <span class="comment">//操作的类型 0是删除 1是插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有删除操作，才可能导致队空 只有插入操作，才可能导致队满</p>
<p>队满条件： <code>front==rear &amp;&amp; tag == 1</code></p>
<p>队空条件： <code>front==rear &amp;&amp; tag == 0</code></p>
</li>
</ol>
<p>&#x3D;&#x3D;队列元素个数&#x3D;&#x3D;</p>
<p><code>(rear+MaxSize-front)%MaxSize</code></p>
<h4 id="队尾指针指向队尾元素的位置-（当前插入元素的位置）"><a href="#队尾指针指向队尾元素的位置-（当前插入元素的位置）" class="headerlink" title="队尾指针指向队尾元素的位置 （当前插入元素的位置）"></a>队尾指针指向队尾元素的位置 （当前插入元素的位置）</h4><p><strong>入队操作</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Q.rear=(Q.rear+<span class="number">1</span> )%MaxSize ; <span class="comment">//先后移</span></span><br><span class="line">Q.data[Q.rear]=x;			<span class="comment">//再存入</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为上述入队操作是先先移动再存入，所以初始化的时候可以让队尾指针指向队头的前一个内存单元即</p>
<p><code>font = 0</code> 时 <code>rear = n-1</code>（n为队列长度）</p>
</blockquote>
<p><strong>队列判空</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Q.rear+<span class="number">1</span>)%MaxSize==Q.front</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;队满判断（3种情况）：&#x3D;&#x3D;</p>
<ol>
<li><p>牺牲一个内存单元 ：即尾指针指向最后一个空内存单元时（下一个就是队头），则就认为此时队满</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(Q.rear + <span class="number">2</span>)%MaxSize == Q.front <span class="comment">//此时尾指针指向当前插入元素，应该+2才能到头指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>增加<code>size</code>变量记录队列长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span> <span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.rear=Q.front=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size; <span class="comment">//队列当前长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入成功 size++； 删除成功 size–;    </p>
<p>队满条件： <code>size==MaxSize</code></p>
<p>队空条件：<code>size == 0</code> </p>
</li>
<li><p>增加<code>tag</code>变量记录当前操作的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span> <span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.rear=Q.front=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tag; <span class="comment">//操作的类型 0是删除 1是插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有删除操作，才可能导致队空 只有插入操作，才可能导致队满</p>
<p>队满条件： <code>front==rear &amp;&amp; tag == 1</code></p>
<p>队空条件： <code>front==rear &amp;&amp; tag == 0</code></p>
</li>
</ol>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302205838134.png" alt="image-20230302205838134"></p>
<h3 id="队列的链式实现"><a href="#队列的链式实现" class="headerlink" title="队列的链式实现"></a>队列的链式实现</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302210437359.png" alt="image-20230302210437359"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;	<span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;		<span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front,*rear; <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<p><strong>队列初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列(带头结点)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front、 rear都指向头结点</span></span><br><span class="line">    Q.front=Q.rear=(LinkNode* )<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列(不带头结点)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始时 front、 rear都指向NULL</span></span><br><span class="line">    Q.front=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>队列判空</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空（带头结点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear) <span class="comment">//if（Q.front-&gt;next == NULL）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空（不带头结点）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front== <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>入队</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队(带头结点)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(L inkQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    L inkNode *s= (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode) )</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    Q.rear-&gt;next=s;		<span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear=s;			<span class="comment">//修改表尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队(不带头结点)</span></span><br><span class="line"><span class="type">void</span> EnQueuelLinkQueue &amp;Q, ElemType x)&#123;</span><br><span class="line">    LinkNode *s=(LinkNode *)<span class="built_in">malloc</span>( <span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    q s-&gt;data=x;</span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//不带头结点的队列，第一个元素入队时需要特别处理</span></span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)&#123;	<span class="comment">//在空队列中插入第一个元素</span></span><br><span class="line">        Q.front = s;		<span class="comment">//修改队头队尾指针</span></span><br><span class="line">        Q.rear=s;	</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	</span><br><span class="line">        Q.rear- -&gt;next=s;	<span class="comment">//新结点插入到rear结点之后</span></span><br><span class="line">        Q. rear=s;			<span class="comment">//修改rear指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出队</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队头元素出队(带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span> <span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q. rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front-&gt;next;</span><br><span class="line">    x=p-&gt;data;				<span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front-&gt;next=p-&gt;next; <span class="comment">//修改头结点的 next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q. rear==p) 			<span class="comment">//此次是最后-个结点出队</span></span><br><span class="line">        Q.rear=Q.front;	<span class="comment">//修改rear 指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302212516495.png" alt="image-20230302212516495"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队头元素出队(不带头结点)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span> <span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q. rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空队</span></span><br><span class="line">    LinkNode *p=Q.front;</span><br><span class="line">    x=p-&gt;data;				<span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front = p-&gt;next; <span class="comment">//修改头结点的 next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q. rear==p) 	&#123;	<span class="comment">//此次是最后-个结点出队</span></span><br><span class="line">        Q.front = <span class="literal">NULL</span>;</span><br><span class="line">        Q.rear = <span class="literal">NULL</span>;	</span><br><span class="line">    &#125;		    </span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302212754770.png" alt="image-20230302212754770"></p>
<p>队满条件：链式存储一般不会队满，除非内存不足</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302212851566.png" alt="image-20230302212851566"></p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302213109970.png" alt="image-20230302213109970"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302213133644.png" alt="image-20230302213133644"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230302214215571.png" alt="image-20230302214215571"></p>
<h2 id="常见考点"><a href="#常见考点" class="headerlink" title="常见考点"></a>常见考点</h2><h3 id="栈的应用——括号匹配"><a href="#栈的应用——括号匹配" class="headerlink" title="栈的应用——括号匹配"></a>栈的应用——括号匹配</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(  (  ( (  )  )  ) )</span><br><span class="line">① ② ③ ④ ④ ③ ② ① </span><br></pre></td></tr></table></figure>

<p>最后出现的左括号最先被匹配（LIFO）</p>
<p>&#x3D;&#x3D;每出现一个右括号，就 “消耗”一个左括号&#x3D;&#x3D;——<strong>出栈</strong></p>
<blockquote>
<p>可用“栈” 实现该特性</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230303090143026.png" alt="image-20230303090143026"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230303090243401.png" alt="image-20230303090243401"></p>
<h3 id="栈的应用——表达式求值1"><a href="#栈的应用——表达式求值1" class="headerlink" title="栈的应用——表达式求值1"></a>栈的应用——表达式求值1</h3><p><strong>中缀、后缀、前缀表达式</strong></p>
<p>中缀表达式：运算符在两个 操作数中间 ，如 <code>a + b - c * d</code></p>
<p>&#x3D;&#x3D;后缀表达式&#x3D;&#x3D;（逆波兰表达式）：运算符在 两个操作数后面，如 <code>a b + c d * -</code></p>
<p>前缀表达式（波兰表达式 ）：运算符在 两个操作数前面，如<code>- + a b * c d</code></p>
<p><strong>中缀转后缀的手算方法</strong>： </p>
<ol>
<li>确定中缀表达式中&#x3D;&#x3D;各个运算符的运算顺序&#x3D;&#x3D;</li>
<li>选择下一个运算符，按照「左操作数 右操作数 运算符」的方式组合成一个新的操作数 </li>
<li>如果还有运算符没被处理，就继续  ②</li>
</ol>
<blockquote>
<p>确定中缀表达式中各个运算符的运算顺序时采用&#x3D;&#x3D;“左优先”原则&#x3D;&#x3D;：只要左边的运算符能先计算，就优先算左边的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A + B - C * D / E + F</span><br><span class="line">  ①  ④   ②  ③  ⑤</span><br><span class="line">A B + C D * E / - F +</span><br><span class="line">   ①     ②  ③ ④  ⑤</span><br></pre></td></tr></table></figure>

<p><strong>后缀表达式的手算方法</strong>： 从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算， 合体为一个操作数 </p>
<blockquote>
<p>注意：两个操作数的左右顺序</p>
</blockquote>
<p><strong>后缀表达式的计算（机算）</strong></p>
<p>用栈实现后缀表达式的计算： </p>
<ol>
<li>从左往右扫描下一个元素，直到处理完所有元素 </li>
<li>若扫描到操作数则压入栈，并回到①；否则执行③ </li>
<li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①</li>
</ol>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230303091336394.png" alt="image-20230303091336394"></p>
<blockquote>
<p>注意：先出栈的 是“右操作数”</p>
<p>若表达式合法， 则最后栈中只会 留下一个元素， 就是最终结果</p>
</blockquote>
<p><strong>中缀表达式转前缀表达式（手算）</strong></p>
<p>中缀转前缀的手算方法： </p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序 </li>
<li>选择下一个运算符，按照「运算符 左操作数 右操作数」的方式组合成一个新的操作数 </li>
<li>如果还有运算符没被处理，就继续 ②</li>
</ol>
<blockquote>
<p>“右优先”原则：只要右边的运算符能先计算，就优先算右边</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A + B * (C - D) – E / F</span><br><span class="line">  ⑤  ③    ②   ④  ①</span><br><span class="line">+ A - * B - C D / E F</span><br><span class="line">⑤  ④ ③  ②    ①</span><br></pre></td></tr></table></figure>

<p>前缀表达式的计算（机算）</p>
<p> 用栈实现前缀表达式的计算： </p>
<ol>
<li>右往左扫描下一个元素，直到处理完所有元素 </li>
<li>若扫描到操作数则压入栈，并回到①；否则执行③ </li>
<li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①</li>
</ol>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230303092033387.png" alt="image-20230303092033387"></p>
<blockquote>
<p>注意：先出栈的 是“左操作数”</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230303092049775.png" alt="image-20230303092049775"></p>
<h3 id="栈的应用——表达式求值2"><a href="#栈的应用——表达式求值2" class="headerlink" title="栈的应用——表达式求值2"></a>栈的应用——表达式求值2</h3><p><strong>中缀表达式转后缀表达式（手算）</strong></p>
<p>中缀转后缀的手算方法： </p>
<ol>
<li>确定中缀表达式中各个运算符的运算顺序 </li>
<li>选择下一个运算符，按照「左操作数 右操作数 运算符」的方式组合成一个新的操作数 </li>
<li>如果还有运算符没被处理，就继续 ②</li>
</ol>
<blockquote>
<p>&#x3D;&#x3D;“左优先”&#x3D;&#x3D;原则：只要左边的运算符能先计算，就优先算左边的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A + B - C * D / E + F</span><br><span class="line">  ①  ④   ②  ③  ⑤</span><br><span class="line">A B + C D * E / - F +</span><br><span class="line">   ①     ②  ③ ④  ⑤</span><br></pre></td></tr></table></figure>

<p><strong>中缀表达式转后缀表达式（机算）</strong></p>
<p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。 从左到右处理各个元素，直到末尾。可能遇到三种情况： </p>
<ol>
<li>遇到&#x3D;&#x3D;操作数&#x3D;&#x3D;。&#x3D;&#x3D;直接加入后缀表达式&#x3D;&#x3D;。 </li>
<li>遇到&#x3D;&#x3D;界限符&#x3D;&#x3D;。遇到<code>&quot;(&quot; </code>直接入栈；遇到<code>&quot;)&quot;</code>则依次弹出栈内运算符并加入后缀表达式，直到 弹出<code>&quot;(&quot; </code>止。注意：<code>&quot;(&quot;</code>不加入后缀表达式。 </li>
<li>遇到&#x3D;&#x3D;运算符&#x3D;&#x3D;。&#x3D;&#x3D;依次弹出栈中优先级高于或等于当前运算符的所有运算符&#x3D;&#x3D;，并加入后缀表达式， 若碰到<code>&quot;(&quot;</code>或栈空则停止。之后再把当前运算符入栈。 </li>
<li>按上述方法处理完所有字符后，&#x3D;&#x3D;将栈中剩余运算符依次弹出&#x3D;&#x3D;，并加入后缀表达式。</li>
</ol>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304102130330.png" alt="image-20230304102130330"></p>
<p><strong>中缀表达式的计算（用栈实现）</strong></p>
<blockquote>
<p><strong>中缀转后缀 + 后缀表达式求值 两个算法的结合</strong></p>
</blockquote>
<p>用栈实现中缀表达式的计算： </p>
<ol>
<li>初始化两个栈，&#x3D;&#x3D;操作数栈&#x3D;&#x3D;和&#x3D;&#x3D;运算符栈&#x3D;&#x3D; </li>
<li>若扫描到操作数，压入操作数栈 </li>
<li>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈（期间也会弹出 运算符，&#x3D;&#x3D;每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算， 运算结果再压回操作数栈）&#x3D;&#x3D;</li>
</ol>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304102428313.png" alt="image-20230304102428313"></p>
<h3 id="栈的应用-——递归"><a href="#栈的应用-——递归" class="headerlink" title="栈的应用 ——递归"></a>栈的应用 ——递归</h3><p>函数调用的特点：最后被调用的函数最先执行结束（LIFO）</p>
<p>函数调用时，需要用一个栈存储： ① 调用返回地址 ② 实参 ③ 局部变量</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304104159268.png" alt="image-20230304104159268"></p>
<p>递归调用时，函数调用栈可称为“递归工作栈” 每进入一层递归，就将递归调用所需信息压入栈顶 每退出一层递归，就从栈顶弹出相应信息</p>
<blockquote>
<p>缺点：太多层递归可能会导致栈溢出</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304104228882.png" alt="image-20230304104228882"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304104245972.png" alt="image-20230304104245972"></p>
<h3 id="队列-的应用"><a href="#队列-的应用" class="headerlink" title="队列 的应用"></a>队列 的应用</h3><p>队列应用——树的层次遍历</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304105126321.png" alt="image-20230304105126321"></p>
<p>队列应用——图的广度优先遍历</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304105143315.png" alt="image-20230304105143315"></p>
<p>队列在操作系统中的应用</p>
<p>多个进程争抢着使用有限的系统资源时，FCFS（First Come First Service， 先来先服务）是一种常用策略。</p>
<h3 id="特殊矩阵-压缩存储"><a href="#特殊矩阵-压缩存储" class="headerlink" title="特殊矩阵 压缩存储"></a>特殊矩阵 压缩存储</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112035871.png" alt="image-20230304112035871"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112055194.png" alt="image-20230304112055194"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112213562.png" alt="image-20230304112213562"></p>
<blockquote>
<p>M行N列的二维数组 <code>b[M][N]</code> 中，若按&#x3D;&#x3D;行优先存储&#x3D;&#x3D;，则 <code>b[i][j]</code> 的存储地址 &#x3D; LOC + (i*N + j) * sizeof(ElemType)</p>
<p>M行N列的二维数组 <code>b[M][N]</code> 中，若按&#x3D;&#x3D;列优先存储&#x3D;&#x3D;，则 <code>b[i][j]</code> 的存储地址  &#x3D; LOC + ( j*M+ i ) * sizeof(ElemType)</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112436730.png" alt="image-20230304112436730"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112446886.png" alt="image-20230304112446886"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112512786.png" alt="image-20230304112512786"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112555956.png" alt="image-20230304112555956"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112641432.png" alt="image-20230304112641432"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112700194.png" alt="image-20230304112700194"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112800649.png" alt="image-20230304112800649"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112807753.png" alt="image-20230304112807753"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112815249.png" alt="image-20230304112815249"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112826985.png" alt="image-20230304112826985"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112907773.png" alt="image-20230304112907773"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112915758.png" alt="image-20230304112915758"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112929278.png" alt="image-20230304112929278"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112937028.png" alt="image-20230304112937028"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112949068.png" alt="image-20230304112949068"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230304112956629.png" alt="image-20230304112956629"></p>
<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><h2 id="串的定义和基本操作"><a href="#串的定义和基本操作" class="headerlink" title="串的定义和基本操作"></a>串的定义和基本操作</h2><p>串，即字符串（String）是由零个或多个字符组成的有限序列。</p>
<p>一般记为 <code>S = ‘a1a2······an&#39; （n ≥0）</code></p>
<p> 其中，S是串名，单引号括起来的字符序列是串的值；ai 可以是字母、数字或其他字符；串 字符的个数n称为串的长度。n &#x3D; 0时的串称为空串（用∅表示）</p>
<p>子串：串中任意个连续的字符组成的子序列。 Eg：’iPhone’，’Pro M’ 是串T 的子串 </p>
<p>主串：包含子串的串。 Eg：T 是子串’iPhone’的主串 </p>
<p>字符在主串中的位置：字符在串中的序号。 Eg：’1’在T中的位置是8(第一次出现) </p>
<p>子串在主串中的位置：子串的第一个字符在主串中的位置 。 Eg：’11 Pro’在 T 中的位置为8</p>
<blockquote>
<p><strong>注意：位序从1开始 而不是从0开始</strong></p>
</blockquote>
<p>串是一种特殊的&#x3D;&#x3D;线性表&#x3D;&#x3D;，数据元素之间呈线性关系</p>
<p>串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等） 串的基本操作，如增删改查等通常&#x3D;&#x3D;以子串为操作对象&#x3D;&#x3D;</p>
<p>假设有串T&#x3D;“”，S&#x3D;”iPhone 11 Pro Max?”，W&#x3D;“Pro”</p>
<p>StrAssign(&amp;T,chars)：赋值操作。把串T赋值为chars。 </p>
<p>StrCopy(&amp;T,S)：复制操作。由串S复制得到串T。 </p>
<p>StrEmpty(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。 </p>
<p>StrLength(S)：求串长。返回串S的元素个数。</p>
<p> ClearString(&amp;S)：清空操作。将S清为空串。 </p>
<p>DestroyString(&amp;S)：销毁串。将串S销毁（回收存储空间）。 </p>
<p>Concat(&amp;T,S1,S2)：串联接。用T返回由S1和S2联接而成的新串 SubString(&amp;Sub,S,pos,len)：求子串。用Sub返回串S的第pos个字符起长度为len的子串。 </p>
<p>&#x3D;&#x3D;Index(S,T)&#x3D;&#x3D;：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的 位置；否则函数值为0。 </p>
<p>&#x3D;&#x3D;StrCompare(S,T)&#x3D;&#x3D;：比较操作。若S&gt;T，则返回值&gt;0；若S&#x3D;T，则返回值&#x3D;0；若S&lt;T，则返回值&lt;0</p>
<p><strong>串的比较操作</strong></p>
<p>StrCompare(S,T)：比较操作。若S&gt;T，则返回值&gt;0；若S&#x3D;T，则返回值&#x3D;0；若S&lt;T，则返回</p>
<blockquote>
<ol>
<li>从第一个字符开始往后依次对比， 先出现更大字符的串就更大</li>
<li>长串的前缀与短串相同时，长串更大</li>
<li>只有两个串完全相 同时，才相等</li>
</ol>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230305094143053.png" alt="image-20230305094143053"></p>
<h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><p><strong>串的顺序存储</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态数组实现分配(定长顺序存储)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255 	<span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[MAXLEN];	<span class="comment">//每个分量存储一个字符</span></span><br><span class="line">    <span class="type">int</span> length;		<span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> *ch;		<span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">    <span class="type">int</span> length;		<span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;		<span class="comment">//动态数组实现(堆分配存储)</span></span><br><span class="line"></span><br><span class="line">HString S;	</span><br><span class="line">S.ch = (<span class="type">char</span> *) <span class="built_in">malloc</span> (MAXLEN * <span class="built_in">sizeof</span>(<span class="type">char</span>));	<span class="comment">//用完需要手动free</span></span><br><span class="line">S. length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230305095021507.png" alt="image-20230305095021507"></p>
<p>接下来对方案四进行讨论</p>
<p>StrAssign(&amp;T,chars)：赋值操作。把串T赋值为chars。 </p>
<p>StrCopy(&amp;T,S)：复制操作。由串S复制得到串T。 </p>
<p>StrEmpty(S)：判空操作。若S为空串，则返回TRUE，否则返回FALSE。 </p>
<p>StrLength(S)：求串长。返回串S的元素个数。 </p>
<p>ClearString(&amp;S)：清空操作。将S清为空串。 </p>
<p>DestroyString(&amp;S)：销毁串。将串S销毁（回收存储空间）。 </p>
<p>Concat(&amp;T,S1,S2)：串联接。用T返回由S1和S2联接而成的新串</p>
<hr>


<p>&#x3D;&#x3D;SubString(&amp;Sub,S,pos,len)：求子串&#x3D;&#x3D;。用Sub返回串S的第pos个字符起长度为len的子串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求子串</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SubString</span><span class="params">(SString &amp;Sub，SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span> (pos+<span class="number">1</span>en<span class="number">-1</span> &gt; S. length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=pos; i&lt;pos+len; i++)</span><br><span class="line">        Sub. ch[i-pos+<span class="number">1</span>] = s.ch[i];</span><br><span class="line">    Sub. length = Len;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255		<span class="comment">//预定义最大串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch [MAXLEN]; 		<span class="comment">//每个分量存储- -个字符</span></span><br><span class="line">    <span class="type">int</span> length;				<span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;StrCompare(S,T)：比较操作&#x3D;&#x3D;。若S&gt;T，则返回值&gt;0；若S&#x3D;T，则返回值&#x3D;0；若S</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">StrCompare</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;: =S.length &amp;&amp; i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i]!=T.ch[i] )</span><br><span class="line">            <span class="keyword">return</span> s.ch[i]-T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更</span></span><br><span class="line">    <span class="keyword">return</span> S. length-T. length; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;Index(S,T)：定位操作&#x3D;&#x3D;。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的 位置；否则函数值为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S, SString T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, n=<span class="built_in">StrLength</span>(S)， m=<span class="built_in">StrLength</span>(T);</span><br><span class="line">    SString sub; 		<span class="comment">//用于暂存子串</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">SubString</span>(sub,S,i,m);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">StrCompare</span>(sub，T)!=<span class="number">0</span>) ++i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> i; <span class="comment">//返回子 串在主串中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; 	<span class="comment">//S中不存在与T相等的子串.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>定位子串操作，其实就是将取子串和字符比较结合在一起，对主串从第一个位置开始，取出与给定串相同长度的子串，进行比较</strong></p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230305100208371.png" alt="image-20230305100208371"></p>
<h2 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h2><p>什么是模式匹配</p>
<p>主串：S&#x3D;‘wangdao’ </p>
<p>子串：’wang’、’ang’、’ao’ …… </p>
<p>模式串：’gda’、’bao’</p>
<p>串的模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置。</p>
<p>&#x3D;&#x3D;Index(S,T)：定位操作&#x3D;&#x3D;。若主串S中存在与串T值相同的子串，则返回它在主串S 中第一次出现的位置；否则函数值为0。</p>
<blockquote>
<p>与上面的串的定位是一样的</p>
</blockquote>
<p>下面将不借助取字符和字符串比较这两个方法，&#x3D;&#x3D;直接使用两个指针&#x3D;&#x3D;实现朴素模式匹配算法</p>
<blockquote>
<p>方法一：i是指向主串的指针，j是指向模式串的指针，两者都是从第一个位置开始</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString S,SString T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;	<span class="comment">//用于将主串的指针移向下一个位置，和返回成功匹配的位序</span></span><br><span class="line">    <span class="type">int</span> i=k, j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T. length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;	<span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            k++;	<span class="comment">//检查下一个子串</span></span><br><span class="line">            i=k;</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法二：下面的主串指针移动有所不同和成功匹配后返回位序不同（&#x3D;&#x3D;不借助变量k&#x3D;&#x3D;）</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index</span><span class="params">(SString s,SString T)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T. length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i; ++j; 	<span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            i=i-j+<span class="number">2</span>;	<span class="comment">//检查下一个子串</span></span><br><span class="line">            j=<span class="number">1</span>;		<span class="comment">//指针后退重新开始匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T.length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;	<span class="comment">//在匹配成功后，i，j会继续移动一个单位才跳出上述循环</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>朴素模式匹配算法性能分析</p>
<p>若模式串长度为m，主串长度为n，则</p>
<p>&#x3D;&#x3D;匹配成功&#x3D;&#x3D;的&#x3D;&#x3D;最好时间复杂度&#x3D;&#x3D;：&#x3D;&#x3D;O(m)&#x3D;&#x3D; </p>
<p>&#x3D;&#x3D;匹配失败&#x3D;&#x3D;的&#x3D;&#x3D;最好时间复杂度&#x3D;&#x3D;：O(n-m+1) &#x3D; O(n-m)≈&#x3D;&#x3D;O(n)&#x3D;&#x3D;  [主串中有n-m+1个，每一次都在第一个字符就发现不匹配]</p>
<p>匹配成功&#x2F;匹配失败最多需要 <code>(n-m+1)*m</code> 次比较，&#x3D;&#x3D;最坏时间复杂度&#x3D;&#x3D;：O((n-m+1)*m)≈&#x3D;&#x3D;O(nm)&#x3D;&#x3D; [一般情况下m&gt;&gt;n]</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230305104109457.png" alt="image-20230305104109457"></p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>朴素模式匹配算法的缺点： 当某些子串与模式串&#x3D;&#x3D;能部分匹配&#x3D;&#x3D;时，主串的扫描指针 i 经常回溯，导致时间开销增加</p>
<p>KMP算法就是在此基础上对已经&#x3D;&#x3D;确认好了的部分&#x3D;&#x3D;进行忽略，直接调整模式串的指针到正确位置（注：&#x3D;&#x3D;模式串回溯指针的位置&#x3D;&#x3D;由&#x3D;&#x3D;模式串本身&#x3D;&#x3D;和&#x3D;&#x3D;主串失配位置&#x3D;&#x3D;决定）</p>
<p>比如对模式串T&#x3D;abaabc，主串S&#x3D;abaabaaabc….来分析</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230308111225652.png" alt="image-20230308111225652"></p>
<p>当第6个元素匹配失败时，可令主串指针i不变，模式串指针j&#x3D;3</p>
<p>当第5个元素匹配失败时，可令主串指针1不变，模式串指针j&#x3D;2</p>
<p>当第4个元素匹配失败时，可令主串指针1不变，模式串指针j&#x3D;2</p>
<p>当第3个元素匹配失败时，可令主串指针i不变，模式串指针j&#x3D;1</p>
<p>当第2个元素匹配失败时，可令主串指针i不变，模式串指针j&#x3D;1</p>
<p>当第1个元素匹配失败时，模式串指针j&#x3D;0，i++，j++</p>
<blockquote>
<p>可用一个next数组来存取这两者（模式串指针回溯的位置和主串失配位置）间的关系）</p>
<p>&#x3D;&#x3D;注：next数组只和模式串有关，和主串无关&#x3D;&#x3D;</p>
</blockquote>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230308111822140.png" alt="image-20230308111822140" style="zoom:67%;">

<blockquote>
<p><strong>根据模式串T，求出next数组——&gt;利用next数组进行匹配(主串指针不回溯)</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KMP算法模式匹配</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_JKMP</span><span class="params">(SString S, SString T,<span class="type">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;	<span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=next[j];		<span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T. length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;		<span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>朴素模式匹配算法，最坏时间复杂度0(mn)</strong> </p>
<p><strong>KMP算法， 最坏时间复杂度0(m+n) （next数组时间复杂度0(m) + 模式匹配过程最坏时间复杂度0(n)）</strong></p>
</blockquote>
<h3 id="求next数组"><a href="#求next数组" class="headerlink" title="求next数组"></a>求next数组</h3><ol>
<li>&#x3D;&#x3D;next[1]都无脑写0&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;next[2]都无脑写1 .&#x3D;&#x3D;</li>
<li>其他next:在不匹配的位置前，划一根美丽的分界线模式串-步一步往后退，直到分界线之前“能对上”，或模式串完全跨过分界线为止。此时i指向哪儿，next数组值就是多少</li>
</ol>
<p>eg：</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230309105651305.png" alt="image-20230309105651305"></p>
<p>此时串T往后移，到线后依旧没找到，故 j&#x3D;1 即next[j] &#x3D; 1</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230309105735985.png" alt="image-20230309105735985"></p>
<p>此时串T往后移，可以对应，故 j&#x3D;2 即next[j] &#x3D; 2</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230309110054464.png" alt="image-20230309110054464"></p>
<p>此时串T往后移，可以对应，故 j&#x3D;3 即next[j] &#x3D; 2</p>
<blockquote>
<p><strong>看竖线前要对应，竖线后的第一个元素对应在串中的位置即为 j 指针的回溯位置，即next[j] 的值</strong></p>
</blockquote>
<h3 id="KMP算法的优化"><a href="#KMP算法的优化" class="headerlink" title="KMP算法的优化"></a>KMP算法的优化</h3><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230309123938382.png" alt="image-20230309123938382" style="zoom:67%;">

<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230309124001994.png" alt="image-20230309124001994" style="zoom:50%;">

<p>模式串中存在相同字符，采用之前的next数组可能导致多做无意义的匹配，比如上述例子中，<strong>主串S的3处失配，则把 j&#x3D;1 但是 j &#x3D; 1 时模式串的字符还是a，一定会失配，使用可以进行优化</strong></p>
<p>对KMP算法的优化即对 <code>next[j]</code> 数组的优化，优化为<code>nextval[j]</code></p>
<p>优化后对KMP算法的逻辑代码不会改变，只是将<code>next[j]</code>换为<code>nextval[j]</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KMP算法模式匹配</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_JKMP</span><span class="params">(SString S, SString T,<span class="type">int</span> nextval[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S.length &amp;&amp; j&lt;=T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S.ch[i]==T.ch[j])&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;	<span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j=nextval[j];		<span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T. length)</span><br><span class="line">        <span class="keyword">return</span> i-T.length;		<span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于next数组的优化：</strong></p>
<ol>
<li>先求出<code>next[j]</code></li>
<li><code>nextval[1]</code>默认写0</li>
<li>序号大于2时，先看对应序号的<code>next[j]</code>，比如 j&#x3D;2 的<code>next[j]</code>为1，然后找模式串中 j&#x3D;1 的字符（a），比较其（a）和 j &#x3D;2 时模式串中对应的字符（b），相等则将 j&#x3D;2 的<code>nextval[2]</code>改为 j&#x3D;1 的<code>nextval[1]</code>，即为0，不等则<code>nextval[2]</code>等于<code>next[2]</code></li>
</ol>
<table>
<thead>
<tr>
<th>序号j</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody><tr>
<td><strong>模式串</strong></td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
</tr>
<tr>
<td><strong>next[j]</strong></td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td><strong>nextval[j]</strong></td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>4</td>
</tr>
</tbody></table>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next数组转nextval数组的代码实现</span></span><br><span class="line">nextval[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">2</span>; j&lt;=T.length; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(T.ch[next[j]]==T.ch[j] )</span><br><span class="line">        nextval[j] =nextval[next [j ] ] ;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        nextval[j]=next[ j ] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="定义和基本术语"><a href="#定义和基本术语" class="headerlink" title="定义和基本术语"></a>定义和基本术语</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230310191111174.png" alt="image-20230310191111174"></p>
<p> &#x3D;&#x3D;空树&#x3D;&#x3D;——结点数为0的树</p>
<p>&#x3D;&#x3D;非空树&#x3D;&#x3D;的特性： </p>
<ol>
<li>有且仅有一个根节点 </li>
<li>没有后继的结点称为“叶子结点”（或终端结点） </li>
<li>有后继的结点称为“分支结点”（或非终端结点） </li>
<li><strong>除了根节点外，任何一个结点都有且仅有一个前驱</strong> </li>
<li>每个结点可以有0个或多个后继</li>
</ol>
<p>树是n（n≥0）个结点的有限集合，n &#x3D; 0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足： </p>
<p>1）有且仅有一个特定的称为根的结点。 </p>
<p>2）当n &gt; 1时，其余结点可分为m（m &gt; 0）个互不相交的有限集合T1, T2,…, Tm，其中每个集 合本身又是一棵树，并且称为根结点的子树。</p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230310191409775.png" alt="image-20230310191409775" style="zoom: 80%;">

<blockquote>
<p>属性： </p>
<ol>
<li>结点的层次（深度）——从上往下数 </li>
<li>结点的高度——从下往上数 </li>
<li>树的高度（深度）——总共多少层 </li>
<li>&#x3D;&#x3D;结点的度&#x3D;&#x3D;——有几个孩子（分支） </li>
<li>&#x3D;&#x3D;树的度&#x3D;&#x3D;——各结点的度的最大值</li>
<li>&#x3D;&#x3D;路径（从上向下）和路径长度&#x3D;&#x3D;：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。</li>
</ol>
</blockquote>
<p>有序树——逻辑上看，树中结点的各子树从左至右是有次序的，不能互换 </p>
<p>无序树——逻辑上看，树中结点的各子树从左至右是无次序的，可以互换</p>
<p>森林：森林是m（m≥0）棵互不相交的树的集合</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230310194612385.png" alt="image-20230310194612385"></p>
<h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><table>
<thead>
<tr>
<th>度为m的树</th>
<th>m叉树</th>
</tr>
</thead>
<tbody><tr>
<td>任意结点的度 ≤ m（最多m个孩子）</td>
<td>任意结点的度 ≤ m（最多m个孩子）</td>
</tr>
<tr>
<td>至少有一个结点度 &#x3D; m（有m个孩子）</td>
<td>允许所有结点的度都 ＜ m</td>
</tr>
<tr>
<td>一定是非空树，少有m+1个结点</td>
<td>可以是空树</td>
</tr>
</tbody></table>
<blockquote>
<p>度为m的树第 i 层至多有 mi-1 个结点（i≥1）</p>
<p>m叉树第 i 层至多有 mi-1 个结点（i≥1）</p>
</blockquote>
<p>具有如下最基本的性质：<br>1）树中的结点数等于所有结点的度数之和加1。<br>2）度为<code>m</code>的树中第i层上至多有  &#x3D;&#x3D;m^(i-1)^&#x3D;&#x3D; 个结点（i≥1）。<br>3）高度为<code>h</code>的<code>m</code>叉树至多有 &#x3D;&#x3D;(m^h^-1)&#x2F;(m-1)&#x3D;&#x3D; 个结点。<br>4）具有<code>n</code>个结点的<code>m</code>叉树的最小高度为 &#x3D;&#x3D;$\lceil log<del>m</del>(n(m-1)+1) \rceil$&#x3D;&#x3D;。</p>
<blockquote>
<p>$\lceil x \rceil$表示向上取整</p>
<p>$\lfloor x \rfloor$表示向下取整</p>
</blockquote>
<p>eg:</p>
<p>【2010统考真题】在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是</p>
<p>设树中度为i（i&#x3D;0,1,2,3,4）的结点数分别为m：树中结点总数为n，则n分支数+1，而分支数又等于树中各结点的之和，即n&#x3D;1+n<del>1</del>+2n<del>2</del>+3n<del>3</del>+4n<del>4</del>&#x3D;n<del>0</del>+n<del>1</del>+n<del>2</del>+n<del>3</del>+n<del>4</del>依题意，n<del>1</del>+2n<del>2</del>+3n<del>3</del>+4n<del>4</del>&#x3D;10+2+30+80&#x3D;122，n<del>0</del>+n<del>1</del>+n<del>2</del>+n<del>3</del>+n<del>4</del>&#x3D;10+1+10+20&#x3D;41，可得出n<del>0</del>&#x3D;82，即树T的叶结点的个数是82。</p>
<blockquote>
<p>注意：综合以上几题，常用于求解树结点与度之间关系的有：</p>
<p><strong>①总结点数&#x3D;n<del>0</del>+n<del>1</del>+n<del>2</del>+n<del>3</del>+….+n<del>m</del></strong></p>
<p><strong>②总分支数&#x3D;1n<del>1</del>+2n<del>2</del>+3n<del>3</del>+4n<del>4</del>+….+mn<del>m</del>（度为m的结点引出m条分支）</strong></p>
<p><strong>⑧总结点数&#x3D;总分支数+1。</strong></p>
</blockquote>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h3><p>二叉树是n（n≥0）个结点的有限集合： </p>
<p>① 或者为&#x3D;&#x3D;空二叉树&#x3D;&#x3D;，即n &#x3D; 0。 </p>
<p>② 或者由一个根结点和两个互不相交的被称为根的&#x3D;&#x3D;左子树&#x3D;&#x3D;和&#x3D;&#x3D;右子树&#x3D;&#x3D;组成。左子树和右子树 又分别是一棵二叉树。 </p>
<p><strong>特点：①每个结点至多只有两棵子树 ②左右子树不能颠倒（二叉树是有序树）</strong></p>
<blockquote>
<p>注意区别：度为2的有序树</p>
</blockquote>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230311105334069.png" alt="image-20230311105334069" style="zoom:80%;">



<p><strong>几个特殊的二叉树：</strong></p>
<p>满二叉树。一棵高度为h，且含有&#x3D;&#x3D;2^h^ - 1&#x3D;&#x3D;个结点的二叉树</p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230311105509043.png" alt="image-20230311105509043" style="zoom: 80%;">

<blockquote>
<p>特点： </p>
<p>①只有&#x3D;&#x3D;最后一层&#x3D;&#x3D;有叶子结点 </p>
<p>②&#x3D;&#x3D;不存在度为 1 的结点&#x3D;&#x3D; </p>
<p><strong>③按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩 子为 2i+1；结点 i 的父节点为$\lfloor i&#x2F;2  \rfloor$ （如果有的话）</strong></p>
</blockquote>
<p>完全二叉树。当且仅当其每个结点都与高度为h的 满二叉树中编号为1～n的结点一一对应时，称为 完全二叉树</p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230311105745225.png" alt="image-20230311105745225">

<blockquote>
<p>特点： </p>
<p>①只有&#x3D;&#x3D;最后两层&#x3D;&#x3D;可能有叶子结点 </p>
<p>②&#x3D;&#x3D;最多只有一个度为1的结点，且该节点只有左孩子没有右孩子&#x3D;&#x3D; </p>
<p><strong>③按层序从 1 开始编号，结点 i 的左孩子为 2i，右孩 子为 2i+1；结点 i 的父节点为$\lfloor i&#x2F;2  \rfloor$ （如果有的话）</strong></p>
<p><strong>④ i≤ $\lfloor i&#x2F;2  \rfloor$  为分支结点， i&gt; $\lfloor i&#x2F;2  \rfloor$  为叶子结点</strong></p>
<p><strong>⑤总结数为n，n为奇数，每个分支节点都有左孩子和右孩子；n为偶数，从n&#x2F;2 开始，其后节点均为叶节点</strong></p>
</blockquote>
<p>二叉排序树。一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p>
<ol>
<li>左子树上所有结点的关键字均小于根结点的关键字； </li>
<li>右子树上所有结点的关键字均大于根结点的关键字。</li>
<li>左子树和右子树又各是一棵二叉排序树。</li>
</ol>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230311110813447.png" alt="image-20230311110813447" style="zoom:80%;">

<blockquote>
<p>二叉排序树可用于元 素的排序、搜索</p>
</blockquote>
<p>平衡二叉树。树上任一结点的&#x3D;&#x3D;左子树&#x3D;&#x3D;和&#x3D;&#x3D;右子树&#x3D;&#x3D;的&#x3D;&#x3D;深度之差不超过1&#x3D;&#x3D;。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230311110856852.png" alt="image-20230311110856852"></p>
<blockquote>
<p>平衡二叉树能有更高的搜索效率</p>
</blockquote>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p>常见考点1：</p>
<p>设非空二叉树中度为0、1和2的结点个数分别为n<del>0</del>、n<del>1</del>和n<del>2</del>，则 n<del>0</del> &#x3D; n<del>2</del> + n<del>1</del> （叶子结点比二分支结点多一个）</p>
<p>假设树中结点总数为 n，则 </p>
<p>① n &#x3D; n<del>0</del> + n<del>1</del> + n<del>2</del> </p>
<p>② n &#x3D; n<del>1</del> + 2n<del>2</del>+1			（树的结点数&#x3D;总度数+1）</p>
<p> $\Longrightarrow$    &#x3D;&#x3D;n<del>0</del> &#x3D; n<del>2</del> + 1&#x3D;&#x3D;</p>
<p>常见考点2：</p>
<p>二叉树第 i 层至多有 &#x3D;&#x3D;2^i-1^&#x3D;&#x3D; 个结点（i≥1），树最多有（满二叉树）&#x3D;&#x3D;2^i^-1&#x3D;&#x3D;个结点 </p>
<p>m叉树第 i 层至多有 &#x3D;&#x3D;m^i-1^&#x3D;&#x3D; 个结点（i≥1），树最多有&#x3D;&#x3D;(m^i^-1)&#x2F;(m-1)&#x3D;&#x3D;</p>
<blockquote>
<p>此时的 i 层相当于高度 h </p>
</blockquote>
<p>常见考点3：</p>
<p><strong>高度为h的二叉树至多有 2^ℎ^ − 1个结点（满二叉树）</strong> </p>
<p><strong>高度为h的m叉树至多有 (m^h^-1)&#x2F;(m-1) 个结点</strong></p>
<p>等比数列求和公式：a + aq + aq^2^ + ……+aq^n-1^ &#x3D; a(1-q^n^)&#x2F;1-q</p>
<hr>


<p>完全二叉树的常考性质</p>
<p>常见考点1：</p>
<p>具有n个（n &gt; 0）结点的完全二叉树的高度h为$\lceil log<del>2</del>(n+1) \rceil$或$\lfloor log<del>2</del>n \rfloor$+1</p>
<p>证明：</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230311113949153.png" alt="image-20230311113949153"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230311113919678.png" alt="image-20230311113919678"></p>
<p>常见考点2：</p>
<p>对于完全二叉树，可以由的结点数 n 推出度为0、1和2的结点个数为n<del>0</del>、n<del>1</del>和n<del>2</del></p>
<p>完全二叉树最多只有一个度为1的结点，即 &#x3D;&#x3D;n<del>1</del>&#x3D;0或1&#x3D;&#x3D; </p>
<p>n<del>0</del> &#x3D; n<del>2</del> + 1 $\Rightarrow$ &#x3D;&#x3D;n0 + n2 一定是奇数&#x3D;&#x3D; </p>
<p><strong>若完全二叉树有2k个（偶数）个结点，则 必有 n<del>1</del>&#x3D;1， n<del>0</del> &#x3D; k， n<del>2</del> &#x3D; k-1</strong> </p>
<p><strong>若完全二叉树有2k-1个（奇数）个结点，则 必有 n<del>1</del>&#x3D;0， n<del>0</del> &#x3D; k， n<del>2</del> &#x3D; k-1</strong></p>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p><strong>顺序存储</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    ElemType value; <span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;	<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line">TreeNode t [MaxSize] ;</span><br><span class="line"><span class="comment">//定义一个长度为MaxSize的数组t，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点</span></span><br><span class="line"><span class="comment">//初始化时所有结点标记为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;MaxSize; i++)&#123;</span><br><span class="line">t[i].isEmpty=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230311205439640.png" alt="image-20230311205439640"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230311205459793.png" alt="image-20230311205459793"></p>
<blockquote>
<p>几个重要常考的基本操作： </p>
<ol>
<li>i 的左孩子 ：2i</li>
<li>i 的右孩子 ：2i+1</li>
<li>i 的父节点 ： $\lfloor i&#x2F;2  \rfloor$ </li>
<li>i 所在的层次： $\lceil log<del>2</del>(n+1) \rceil$或$\lfloor log<del>2</del>n \rfloor$+1</li>
</ol>
<p> 若&#x3D;&#x3D;完全二叉树&#x3D;&#x3D;中共有n个结点，则 </p>
<ol>
<li>判断 i 是否有左孩子？  2i ≤ n </li>
<li>判断 i 是否有右孩子？  2i+1 ≤ n</li>
<li>判断 i 是否是叶子&#x2F;分支结点？i &gt; $\lfloor n&#x2F;2 \rfloor$ ?</li>
</ol>
</blockquote>
<p>如果不是完全二叉树， 依然按层序将各节点顺序存储，那么…将无法从结点编号反映 出结点间的逻辑关系</p>
<p><strong>二叉树的顺序存储中，一定要把二叉 树的结点编号与完全二叉树对应起来</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230311210838976.png" alt="image-20230311210838976"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230311210921630.png" alt="image-20230311210921630"></p>
<p>最坏情况：高度为 h 且只有 h 个结点的单 支树（所有结点只有右孩子），也至少需 要 2h-1 个存储单元</p>
<p><strong>结论：二叉树的顺序存储结构，只适合存储完全二叉树</strong></p>
<hr>


<p>链式存储</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点(链式存储)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">EtemType data;		<span class="comment">//数据域</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild,*rchild;	<span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode ,*BiTree;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230311211217066.png" alt="image-20230311211217066"></p>
<p>&#x3D;&#x3D;n个结点的二叉链表共有 n+1 个空链域&#x3D;&#x3D;——可以用于构造 线索二叉树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ElemType</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild , *rchild;</span><br><span class="line">&#125;BiTNode ,*BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一棵空树</span></span><br><span class="line">BiTree root = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入根节点</span></span><br><span class="line">root = (BiTree) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span> (BiTNode));</span><br><span class="line">root-&gt;data = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">root-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入新结点</span></span><br><span class="line">BiTNode * p = (BiTNode *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">p-&gt;data = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">p-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">root-&gt;lchild = p;	<span class="comment">//作为根节点的左孩子</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三叉链表——方便找父结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild , *rchild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *parent;</span><br><span class="line">&#125;BiTNode ,*BiTree;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="先-x2F-中-x2F-后序遍历"><a href="#先-x2F-中-x2F-后序遍历" class="headerlink" title="先&#x2F;中&#x2F;后序遍历"></a>先&#x2F;中&#x2F;后序遍历</h3><p>二叉树的递归特性： </p>
<p>①要么是个空二叉树</p>
<p> ②要么就是由“根节点+左子树+右子树”组成的二叉树</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230312094419509.png" alt="image-20230312094419509"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230312094438624.png" alt="image-20230312094438624"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230312094509494.png" alt="image-20230312094509494"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230312094536672.png" alt="image-20230312094536672"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild , *rchild;</span><br><span class="line">&#125;BiTNode ,*BiTree;</span><br></pre></td></tr></table></figure>

<p>先序遍历（PreOrder）的操作过程如下： </p>
<ol>
<li>若二叉树为空，则什么也不做； </li>
<li>若二叉树非空： <ol>
<li>访问根结点； </li>
<li>先序遍历左子树； </li>
<li>先序遍历右子树。</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);	<span class="comment">//访问根结点</span></span><br><span class="line">        <span class="built_in">Pre0rder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>中序遍历（InOrder）的操作过程如下： </p>
<ol>
<li>若二叉树为空，则什么也不做； </li>
<li>若二叉树非空： <ol>
<li>先序遍历左子树；</li>
<li>访问根结点；  </li>
<li>先序遍历右子树。</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;        </span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);	<span class="comment">//访问根结点</span></span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历（PostOrder）的操作过程如下： </p>
<ol>
<li>若二叉树为空，则什么也不做； </li>
<li>若二叉树非空： <ol>
<li>先序遍历左子树；</li>
<li>先序遍历右子树。</li>
<li>访问根结点；</li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;        </span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PostOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);	<span class="comment">//访问根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>空间复杂度： O(h)</p>
</blockquote>
<p>求遍历序列，路线法：</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230312095411151.png" alt="image-20230312095411151"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230312095437732.png" alt="image-20230312095437732"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230312095448962.png" alt="image-20230312095448962"></p>
<p>eg：求树的深度（应用）</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230312095554130.png" alt="image-20230312095554130"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">treeDepth</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">treeDepth</span>(T-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">treeDepth</span>(T-&gt;rchild);</span><br><span class="line">        <span class="comment">//树的深度=Max (左子树深度,右子树深度)+1</span></span><br><span class="line">        <span class="keyword">return</span> l&gt;r ? l+<span class="number">1</span> : r+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230312095828544.png" alt="image-20230312095828544"></p>
<h3 id="二叉树的层次遍历（广度优先）"><a href="#二叉树的层次遍历（广度优先）" class="headerlink" title="二叉树的层次遍历（广度优先）"></a>二叉树的层次遍历（广度优先）</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230312095941077.png" alt="image-20230312095941077"></p>
<p>算法思想： </p>
<ol>
<li>初始化一个辅助队列 </li>
<li>根结点入队 </li>
<li>&#x3D;&#x3D;若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有的话）&#x3D;&#x3D; </li>
<li>重复③直至队列为空</li>
</ol>
<p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点(链式存储)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;</span><br><span class="line">&#125;BiTNode ,*BiTree;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//链式队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    BiTNode * data;	<span class="comment">//存指针而不是结点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    LinkNode *f ront,*rear; <span class="comment">//队头队尾</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Level0rder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);		<span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,T);		<span class="comment">//将根结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(Q))&#123;	<span class="comment">//队列不空则循环</span></span><br><span class="line">        <span class="built_in">DeQueue</span>(Q，p);		<span class="comment">//队头结点出队</span></span><br><span class="line">        <span class="built_in">visit</span>(p);			<span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild !=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q,p-&gt;lchild); <span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild !=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q,p-&gt;rchild); <span class="comment">//右孩子入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h3><p>结论：一个层序遍历序列可能对应多种二叉树形态</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230318094646182.png" alt="image-20230318094646182"></p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230318094735501.png" alt="image-20230318094735501" style="zoom:67%;">

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230318094835798.png" alt="image-20230318094835798"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230318094855677.png" alt="image-20230318094855677"></p>
<blockquote>
<p><strong>结论：前序、后序、层序的两两组合无法唯一 确定一棵二叉树</strong></p>
<p><strong>只有和中序结合，才能确定唯一的一棵二叉树</strong></p>
</blockquote>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230318143245900.png" alt="image-20230318143245900"></p>
<blockquote>
<p>指向前驱、后继的指针称为“线索”</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的结点(链式存储)  术语: 二叉链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span>&#123; </span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *Lchild,*rchild;</span><br><span class="line">&#125;BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索二叉树结点   术语：线索链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> * lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag,rtag; <span class="comment">//左、 右线索标志</span></span><br><span class="line">&#125;ThreadNode ,*ThreadTree;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230318152105651.png" alt="image-20230318152105651"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230318152130261.png" alt="image-20230318152130261"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230318152159336.png" alt="image-20230318152159336"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230318152211495.png" alt="image-20230318152211495"></p>
<h3 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h3><p>用土办法找到中序前驱</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);		<span class="comment">//访问根结点</span></span><br><span class="line">        <span class="built_in">In0rder</span>(T-&gt;rchild);		<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问结点q</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span> <span class="params">(BiTNode * q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q==p)		<span class="comment">//从当前访问结点刚好是结点p </span></span><br><span class="line">        <span class="keyword">final</span> = pre;	<span class="comment">//找到p的前驱</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pre = q;		<span class="comment">//pre指向当前访问的结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助全局变量，用于查找结点p的前驱</span></span><br><span class="line">BiTNode *p;		<span class="comment">//p指向目标结点</span></span><br><span class="line">BiTNode * pre=<span class="literal">NULL</span>;	<span class="comment">//指向当前访问结点的前驱</span></span><br><span class="line">BiTNode * <span class="keyword">final</span>=<span class="literal">NULL</span>; <span class="comment">//用于记录最终结果</span></span><br></pre></td></tr></table></figure>

<p>二叉树线索化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> * lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;	<span class="comment">//左、右线索标志</span></span><br><span class="line">&#125;ThreadNode ,* ThreadTree ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>初步建成的树， <code>ltag、rtag=0</code> ——这一步是在建立树的时候完成的</p>
</blockquote>
<p>中序线索化（写法一）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历土叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;lchild);	<span class="comment">//中序遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);	<span class="comment">//访问根节点</span></span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;rchild); <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild==<span class="literal">NULL</span>)&#123;<span class="comment">//左子树为空,建立前驱线索</span></span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild=q; <span class="comment">//建立前驱结 点的后继线索</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量，pre,指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    pre=<span class="literal">NULL</span>;	<span class="comment">//pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;	<span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        <span class="built_in">InThread</span>(T);	<span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild= =<span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;	<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码注意要处理最后一个节点的右孩子</p>
</blockquote>
<p>中序线索化（写法二）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InThread</span>(T-&gt;lchild);</span><br><span class="line">    <span class="comment">//下面的相当于写法一的visit</span></span><br><span class="line">	<span class="keyword">if</span>(q-&gt;lchild==<span class="literal">NULL</span>)&#123;<span class="comment">//左子树为空,建立前驱线索</span></span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild=q; <span class="comment">//建立前驱结 点的后继线索</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pre=q;</span><br><span class="line">    <span class="built_in">InThread</span>(p-&gt;rchild,pre)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span> <span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre=<span class="literal">NULL</span>;  <span class="comment">//与一的区别，此处为局域变量</span></span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;	<span class="comment">//非空二叉树，线索化</span></span><br><span class="line">        <span class="built_in">InThread</span>(T,pre);	<span class="comment">//线索化二叉树</span></span><br><span class="line">        pre-&gt;rchild=<span class="literal">NULL</span>;		<span class="comment">//处理遍历的最后一个结点，此处可以不做判断</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先序线索化（写法一）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历土叉树，一边遍历一边线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);	<span class="comment">//访问根节点</span></span><br><span class="line">        <span class="keyword">if</span>(T-&gt;ltag==<span class="number">0</span>) <span class="comment">// !lchild不是前驱线索</span></span><br><span class="line">            <span class="built_in">PreThread</span>(T-&gt;lchild);	<span class="comment">//中序遍历左子树</span></span><br><span class="line">        <span class="built_in">PreThread</span>(T-&gt;rchild); <span class="comment">//中序遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;lchild==<span class="literal">NULL</span>)&#123;<span class="comment">//左子树为空,建立前驱线索</span></span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild=q; <span class="comment">//建立前驱结 点的后继线索</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量，pre,指向当前访问结点的前驱</span></span><br><span class="line">ThreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    pre=<span class="literal">NULL</span>;	<span class="comment">//pre初始为NULL</span></span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;	<span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        <span class="built_in">PreThread</span>(T);	<span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild= =<span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;	<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先序线索化（写法二）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面的相当于写法一的visit</span></span><br><span class="line">	<span class="keyword">if</span>(q-&gt;lchild==<span class="literal">NULL</span>)&#123;<span class="comment">//左子树为空,建立前驱线索</span></span><br><span class="line">        q-&gt;lchild=pre;</span><br><span class="line">        q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pre-&gt;rchild=q; <span class="comment">//建立前驱结 点的后继线索</span></span><br><span class="line">        pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;ltag==<span class="number">0</span>)   <span class="comment">//!lchild不是前驱线索</span></span><br><span class="line">	    <span class="built_in">InThread</span>(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">InThread</span>(p-&gt;rchild,pre)</span><br><span class="line">    pre=q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span> <span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre=<span class="literal">NULL</span>;  <span class="comment">//与一的区别，此处为局域变量</span></span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;	<span class="comment">//非空二叉树，线索化</span></span><br><span class="line">        <span class="built_in">PreThread</span>(T,pre);	<span class="comment">//线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild= =<span class="literal">NULL</span>)</span><br><span class="line">            pre-&gt;rtag=<span class="number">1</span>;	<span class="comment">//处理遍历的最后一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：前序遍历，需要对遍历左子树时进行判断处理，因为如果左子树为空时，先<code>visit</code>操作会把其左指针改为线索指针（即指向其父节点），这时再直接遍历会出错，通过<code>ltag</code>判断其是否为线索指针</p>
</blockquote>
<p>后序线索化：同中序线索化，无特殊要求，只需要将顺序改一下即可</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230318163514116.png" alt="image-20230318163514116"></p>
<h3 id="在线索二叉树找前驱和后继"><a href="#在线索二叉树找前驱和后继" class="headerlink" title="在线索二叉树找前驱和后继"></a>在线索二叉树找前驱和后继</h3><h4 id="中序线索二叉树找中序后继"><a href="#中序线索二叉树找中序后继" class="headerlink" title="中序线索二叉树找中序后继"></a>中序线索二叉树找中序后继</h4><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230319110957078.png" alt="image-20230319110957078"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以P为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span> <span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环找到最左下结点(不一定是叶结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>) p=p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p; .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到结点p的后继结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span>&#123;	<span class="comment">//右子树中最左下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Firstnode</span>(p-&gt;rchild) ;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//rtag==1直接返回后继线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行中序遍历(利用线索实现的非递归算法)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode *T)</span></span>&#123;	<span class="comment">//空间复杂度0(1)</span></span><br><span class="line">    <span class="comment">//不断寻找后继，达到遍历效果</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadNode *p=<span class="built_in">Firstnode</span>(T);p!=<span class="literal">NULL</span>; p=<span class="built_in">Nextnode</span>(p))</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="中序线索二叉树找中序前驱"><a href="#中序线索二叉树找中序前驱" class="headerlink" title="中序线索二叉树找中序前驱"></a>中序线索二叉树找中序前驱</h4><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230319111436723.png" alt="image-20230319111436723"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以P为根的子树中，最后个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Lastnode</span> <span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环找到最右下结点(不一定是叶结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rtag==<span class="number">0</span>) p=p-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> p; .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在中序线索二叉树中找到结点p的前驱结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Prenode</span><span class="params">(ThreadNode *p)</span></span>&#123;	<span class="comment">//右子树中最左下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Lastnode</span>(p-&gt;lchild) ;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild; <span class="comment">//rtag==1直接返回前驱线索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对中序线索二叉树进行逆向中序遍历(利用线索实现的非递归算法)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RevInorder</span><span class="params">(ThreadNode *T)</span></span>&#123;	<span class="comment">//空间复杂度0(1)</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadNode *p=<span class="built_in">Lastnode</span>(T);p!=<span class="literal">NULL</span>; p=<span class="built_in">Prenode</span>(p))</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="先序线索二叉树找先序后继"><a href="#先序线索二叉树找先序后继" class="headerlink" title="先序线索二叉树找先序后继"></a>先序线索二叉树找先序后继</h4><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230319112307091.png" alt="image-20230319112307091"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在先序线索二叉树中找到结点p的后继结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span>&#123;	<span class="comment">//右子树中最左下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)  <span class="comment">//此时要分两种情况：是否有左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)</span><br><span class="line">	        <span class="keyword">return</span> p-&gt;lchild ;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p-&gt;rchild ;</span><br><span class="line">    <span class="keyword">else</span> 	<span class="comment">//rtaag=1代表左后孩子都没有，都线索化了，那么其后继就是右线索</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//rtag==1直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="先序线索二叉树找先序前驱（三叉链表）"><a href="#先序线索二叉树找先序前驱（三叉链表）" class="headerlink" title="先序线索二叉树找先序前驱（三叉链表）"></a>先序线索二叉树找先序前驱（三叉链表）</h4><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230319114749597.png" alt="image-20230319114749597"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230319114915563.png" alt="image-20230319114915563"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三叉链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> * lchild, *rchild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *parent;</span><br><span class="line">    <span class="type">int</span> ltag,rtag; <span class="comment">//左、 右线索标志</span></span><br><span class="line">&#125;ThreadNode ,*ThreadTree;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以P为根的子树中，最后个被先序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Lastnode</span> <span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环找到最右下结点(不一定是叶结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span> || p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line">            p=p-&gt;rchild;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)&#123; <span class="comment">//上面循环出来满足 p-&gt;rtag==1  </span></span><br><span class="line">            p=p-&gt;lchild;	</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if(p-&gt;rtag==1 &amp;&amp; p-&gt;ltag==1)从上述循环出来就已经满足了这个条件了</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到以P为孩子的子树中，其前驱</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Parentnode</span> <span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//p为左节点 或 p为右节点且没有其父节点左节点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;parent!=null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;parent-&gt;lchild==p)</span><br><span class="line">            <span class="keyword">return</span> p-&gt;parent;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;parent-&gt;ltag==<span class="number">1</span> &amp;&amp; p-&gt;parent-&gt;rchild==p)</span><br><span class="line">            <span class="keyword">return</span> p-&gt;parent;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;parent-&gt;ltag==<span class="number">0</span> &amp;&amp; p-&gt;parent-&gt;rchild==p)&#123;</span><br><span class="line">            <span class="built_in">Lastnode</span>(p-&gt;parent-&gt;lchild)</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> null; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在先序线索二叉树中找到结点p的前驱结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Prenode</span><span class="params">(ThreadNode *p)</span></span>&#123;	<span class="comment">//右子树中最左下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Parentnode</span>(p) ;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild; <span class="comment">//ltag==1直接返回前驱线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后序线索二叉树找后序后继（三叉链表）"><a href="#后序线索二叉树找后序后继（三叉链表）" class="headerlink" title="后序线索二叉树找后序后继（三叉链表）"></a>后序线索二叉树找后序后继（三叉链表）</h4><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230319131209650.png" alt="image-20230319131209650"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230319131221138.png" alt="image-20230319131221138"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三叉链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span>&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> * lchild, *rchild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *parent;</span><br><span class="line">    <span class="type">int</span> ltag,rtag; <span class="comment">//左、 右线索标志</span></span><br><span class="line">&#125;ThreadNode ,*ThreadTree;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以P为根的子树中，第一个被后序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Lastnode</span> <span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环找到最左下结点(不一定是叶结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span> || p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//有左孩子就一直向左，没有就检查右孩子，同时没有才能算找到</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)&#123; <span class="comment">//上面循环出来满足 p-&gt;rtag==1  </span></span><br><span class="line">            p=p-&gt;rchild;	</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if(p-&gt;rtag==1 &amp;&amp; p-&gt;ltag==1)从上述循环出来就已经满足了这个条件了</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到以P为孩子的子树中，其后继</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Parentnode</span> <span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//p为左节点 或 p为右节点且没有其父节点左节点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;parent!=null)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;parent-&gt;rchild==p)</span><br><span class="line">            <span class="keyword">return</span> p-&gt;parent;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;parent-&gt;rtag==<span class="number">1</span> &amp;&amp; p-&gt;parent-&gt;lchild==p)</span><br><span class="line">            <span class="keyword">return</span> p-&gt;parent;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;parent-&gt;rtag==<span class="number">0</span> &amp;&amp; p-&gt;parent-&gt;lchild==p)&#123;</span><br><span class="line">            <span class="built_in">Lastnode</span>(p-&gt;parent-&gt;rchild)</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> null; </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在后序线索二叉树中找到结点p的后继结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Nextnode</span><span class="params">(ThreadNode *p)</span></span>&#123;	</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Parentnode</span>(p) ;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild; <span class="comment">//rtag==1直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后序线索二叉树找后序前驱"><a href="#后序线索二叉树找后序前驱" class="headerlink" title="后序线索二叉树找后序前驱"></a>后序线索二叉树找后序前驱</h4><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230319132652201.png" alt="image-20230319132652201"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在后序线索二叉树中找到结点p的前驱结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Prenode</span><span class="params">(ThreadNode *p)</span></span>&#123;	<span class="comment">//右子树中最左下结点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag==<span class="number">0</span>)  <span class="comment">//此时要分两种情况：是否有左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)</span><br><span class="line">	        <span class="keyword">return</span> p-&gt;rchild ;</span><br><span class="line">    	<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p-&gt;lchild ;</span><br><span class="line">    <span class="keyword">else</span> 	<span class="comment">//rtaag=1代表左后孩子都没有，都线索化了，那么其后继就是右线索</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild; <span class="comment">//rtag==1直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230319132904864.png" alt="image-20230319132904864"></p>
<h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p>树的逻辑结构</p>
<p>树是n（n≥0）个结点的有限集合，n &#x3D; 0时，称为空树，这是一种特殊情况。在任意一棵非 空树中应满足： </p>
<p>1）有且仅有一个特定的称为根的结点。 </p>
<p>2）当n &gt; 1时，其余结点可分为m（m &gt; 0）个&#x3D;&#x3D;互不相交的有限集合&#x3D;&#x3D;T1, T2,…, Tm，其中每个集 合本身又是一棵树，并且称为根结点的子树。</p>
<blockquote>
<p>树是一种递归定义的数据结构</p>
</blockquote>
<p>双亲表示法（顺序存储）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">双亲表示法：每个结点中保存指向双亲的“指针”</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ TREE_ SIZE 100		<span class="comment">//树中最多结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;		<span class="comment">//树的结点定义</span></span><br><span class="line">    ElemType data;		<span class="comment">//数据元素</span></span><br><span class="line">    <span class="type">int</span> parent;			<span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;		<span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes [MAX_ TREE_ SIZE] ;	<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n;		<span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>新增数据元素， 无需按逻辑上 的次序存储</p>
</blockquote>
<p>删除节点：</p>
<p>方案一：将<code>parent</code>指针改为-1（空数据导致遍历更慢） </p>
<p>方案二：将后面节点全部往前移</p>
<blockquote>
<p>优点：查指定结点的双亲很 方便</p>
<p>缺点：查指定结点的孩子只 能从头遍历</p>
</blockquote>
<hr>


<p>孩子表示法（顺序+链式存储）</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322171357367.png" alt="image-20230322171357367"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//孩子表示法：顺序存储各个节点，每个结点中保存孩子链表头指针</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> child; <span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next; <span class="comment">//下一个孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CTNode</span> *firstChild; <span class="comment">//第一 个孩子</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    CTBox nodes [MAX_ TREE_ _SIZE] ;</span><br><span class="line">    <span class="type">int</span> n, r; <span class="comment">//结点数和根的位置</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure>

<hr>


<p><strong>孩子兄弟表示法（链式存储）</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322171806576.png" alt="image-20230322171806576"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的存储一-孩子 兄弟表示法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span>&#123;</span><br><span class="line">    ElemType data; <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span> *firstchild, *nextsibling; <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode, *CSTree;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322171928143.png" alt="image-20230322171928143"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322172058205.png" alt="image-20230322172058205"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322172115480.png" alt="image-20230322172115480"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322172129964.png" alt="image-20230322172129964"></p>
<h3 id="树、森林的遍历"><a href="#树、森林的遍历" class="headerlink" title="树、森林的遍历"></a>树、森林的遍历</h3><p>树的先根遍历</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322174118287.png" alt="image-20230322174118287"></p>
<p>树的后根遍历</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322174133412.png" alt="image-20230322174133412"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322174159616.png" alt="image-20230322174159616"></p>
<p>森林的先序遍历</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322174217726.png" alt="image-20230322174217726"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322174232029.png" alt="image-20230322174232029"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322174246559.png" alt="image-20230322174246559"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230322174323937.png" alt="image-20230322174323937"></p>
<h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><h3 id="二叉排序树的定义"><a href="#二叉排序树的定义" class="headerlink" title="二叉排序树的定义"></a>二叉排序树的定义</h3><p>二叉排序树，又称二叉查找树（BST，Binary Search Tree） 一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树： </p>
<ol>
<li>左子树上所有结点的关键字均小于根结点的关键字； </li>
<li>右子树上所有结点的关键字均大于根结点的关键字。 </li>
<li>左子树和右子树又各是一棵二叉排序树。</li>
</ol>
<blockquote>
<p>&#x3D;&#x3D;左子树结点值 &lt; 根结点值 &lt; 右子树结点值&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;进行中序遍历，可以得到一个递增的有序序列&#x3D;&#x3D;</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326102559740.png" alt="image-20230326102559740"></p>
<h3 id="二叉排序树的查找"><a href="#二叉排序树的查找" class="headerlink" title="二叉排序树的查找"></a>二叉排序树的查找</h3><p>左子树结点值 &lt; 根结点值 &lt; 右子树结点值</p>
<p>若树非空，目标值与根结点的值比较： </p>
<p>若相等，则查找成功； </p>
<p>若小于根结点，则在左子树上查找，否则在右子树上查找。 </p>
<p>查找成功，返回结点指针；查找失败返回NULL</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉排序树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *Lchild, *rchild;</span><br><span class="line">&#125;BSTNode , *BSTree; </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树中查找值为key, 的结点</span></span><br><span class="line"><span class="comment">//最坏空间复杂度0(1)</span></span><br><span class="line"><span class="function">BSTNode *BST_ <span class="title">Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;key!=T-&gt;key)&#123; 	<span class="comment">//若树空或等 于根结点值，则结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;key)</span><br><span class="line">            T=T-&gt;lchild; 	<span class="comment">//小于， 则在左子树上查找</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            T=T-&gt;rchild;	<span class="comment">//大于，则在右子树.上查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树中查找值为key 的结点(递归实现)</span></span><br><span class="line"><span class="comment">//最坏空间复杂度0(h)</span></span><br><span class="line">    <span class="function">BSTNode *<span class="title">BSTSearch</span><span class="params">(BSTree T,<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">//查找失败</span></span><br><span class="line">    <span class="keyword">if</span> (key==T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;    <span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(T-&gt;lchild, key); <span class="comment">//在左子树中找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(T-&gt;rchild, Key); <span class="comment">//在右子树中找</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉排序树的插入"><a href="#二叉排序树的插入" class="headerlink" title="二叉排序树的插入"></a>二叉排序树的插入</h3><p>若原二叉排序树为空，则直接插入结点；否则，若关键字k小于根结 点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树插入关键字为k的新结点(递归实现).</span></span><br><span class="line"><span class="comment">//最坏空间复杂度0(h)</span></span><br><span class="line"><span class="comment">//新插入的结点一定是叶子</span></span><br><span class="line"><span class="function"><span class="type">int</span> BST_ <span class="title">Insert</span><span class="params">(BSTree &amp;T, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123; <span class="comment">//原树为空, 新插入的结点为根结点</span></span><br><span class="line">        T=(BSTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;key=k; </span><br><span class="line">        T-&gt;lchild=T-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">//返回1,插入成功</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k==T-&gt;key)	<span class="comment">//树中存在相同关键字的结点，插入失败:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)	<span class="comment">//插入到T的左子树</span></span><br><span class="line">        <span class="keyword">return</span>, BST_ <span class="built_in">Insert</span>(T-&gt;lchild,k);</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//插入到T的右子树</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        <span class="built_in">BST_Insert</span>(T-&gt;rchild,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉排序树的构造"><a href="#二叉排序树的构造" class="headerlink" title="二叉排序树的构造"></a>二叉排序树的构造</h3><p>例1：按照序列str&#x3D;{50, 66, 60, 26, 21, 30, 70, 68}建立BST</p>
<p>例2：按照序列str&#x3D;{50, 26, 21, 30, 66, 60, 70, 68}建立BST</p>
<blockquote>
<p>不同的关键字序列可能得到同款二叉排序树，也可能得到不同款二叉排序树</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照str[] 中的关键字序列建立二叉排序树</span></span><br><span class="line"><span class="type">void</span> Creat_ _BST(BSTree &amp;T,<span class="type">int</span> str[] , intn)&#123;</span><br><span class="line">    T=<span class="literal">NULL</span> ;</span><br><span class="line">    <span class="comment">//初始时T为空树 ( </span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        <span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">        <span class="function">BST_ <span class="title">Insert</span><span class="params">(T,str[i])</span></span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉排序树的删除"><a href="#二叉排序树的删除" class="headerlink" title="二叉排序树的删除"></a>二叉排序树的删除</h3><p>先搜索找到目标结点： </p>
<p>① 若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326103612515.png" alt="image-20230326103612515"></p>
<p>② 若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326103627938.png" alt="image-20230326103627938"></p>
<p>③ 若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这 个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</p>
<p>中序遍历——左 根 &#x3D;&#x3D;右&#x3D;&#x3D; </p>
<p>​							左 根 (&#x3D;&#x3D;左&#x3D;&#x3D; 根 右) </p>
<p>​							左 根 ((&#x3D;&#x3D;左&#x3D;&#x3D; 根 右) 根 右) </p>
<p> z的后继：z的右子树中最左下结点（该节点 一定没有左子树）</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326103814884.png" alt="image-20230326103814884"></p>
<p>） 中序遍历——&#x3D;&#x3D;左&#x3D;&#x3D; 根 右 </p>
<p>​								(左 根 &#x3D;&#x3D;右&#x3D;&#x3D;) 根 右 </p>
<p>​								(左 根 (左 根 &#x3D;&#x3D;右&#x3D;&#x3D;) ) 根 右</p>
<p>z的前驱：z的左子树中最右下结点（该节点一 定没有右子树）</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326103955520.png" alt="image-20230326103955520"></p>
<h3 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104048118.png" alt="image-20230326104048118"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104118559.png" alt="image-20230326104118559"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104125701.png" alt="image-20230326104125701"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104135279.png" alt="image-20230326104135279"></p>
<h2 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树(AVL)"></a>平衡二叉树(AVL)</h2><h3 id="平衡二叉树的定义"><a href="#平衡二叉树的定义" class="headerlink" title="平衡二叉树的定义"></a>平衡二叉树的定义</h3><p>平衡二叉树（Balanced Binary Tree），简称平衡树（AVL树）——树上任一结点的左子树和右子树的 高度之差不超过1。 结点的平衡因子&#x3D;左子树高-右子树高。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVLNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;    <span class="comment">//数据域</span></span><br><span class="line">    <span class="type">int</span> balance;    <span class="comment">//平衡因子</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">AVLNode</span> *lchild,*rchild;</span><br><span class="line">&#125;AVLNode, *AVLTree;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104415227.png" alt="image-20230326104415227"></p>
<h3 id="平衡二叉树的插入"><a href="#平衡二叉树的插入" class="headerlink" title="平衡二叉树的插入"></a>平衡二叉树的插入</h3><p>每次调整的对象都是&#x3D;&#x3D;“最小不平衡子树”&#x3D;&#x3D;</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104503419.png" alt="image-20230326104503419"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104514574.png" alt="image-20230326104514574"></p>
<h3 id="平衡二叉树的删除"><a href="#平衡二叉树的删除" class="headerlink" title="平衡二叉树的删除"></a>平衡二叉树的删除</h3><p>平衡二叉树的删除操作:</p>
<ul>
<li><p>删除结点后，要保持二叉排序树的特性不变(左&lt;中&lt;右 )</p>
</li>
<li><p>若删除结点导致不平衡，则需要调整平衡</p>
</li>
</ul>
<p>平衡二叉树的删除操作具体步骤:</p>
<p>  ①删除结点(方法同“二叉排序树”)</p>
<p>​		&#x3D;&#x3D;●若删除的结点是叶子，直接删。&#x3D;&#x3D;<br>​		&#x3D;&#x3D;●若删除的结点只有一个子树，用子树顶替删除位置<br>​		●若删除的结点有两棵子树，用前驱(或后继)结点顶替，并转换为对前驱(或后继)结点的删除。&#x3D;&#x3D;</p>
<p>  ②一路向北找到最小不平衡子树，找不到就完结撒花</p>
<p>  ③找最小不平衡子树下，“个头” 最高的儿子、孙子</p>
<p>  ④根据孙子的位置，调整平衡(LL&#x2F;RR&#x2F;LR&#x2F;RL )</p>
<p>​		&#x3D;&#x3D;●孙子在LL:儿子右单旋&#x3D;&#x3D;<br>​		&#x3D;&#x3D;●孙子在RR:儿子左单旋&#x3D;&#x3D;<br>​		&#x3D;&#x3D;●孙子在LR:孙子先左旋，再右旋<br>​		●孙子在RL:孙子先右旋，再左旋&#x3D;&#x3D;</p>
<p>  ⑤如果不平衡向上传导，继续②</p>
<p>​		&#x3D;&#x3D;●对最小不平衡子树的旋转可能导致树变矮，从而导致上层祖先不平衡(不平衡向上传递)&#x3D;&#x3D;</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230422131049562.png" alt="image-20230422131049562"></p>
<blockquote>
<p><em>平衡二叉树删除操作时间复杂度&#x3D;O(log<del>2</del>n)</em></p>
</blockquote>
<h3 id="调整最小不平衡子树"><a href="#调整最小不平衡子树" class="headerlink" title="调整最小不平衡子树"></a>调整最小不平衡子树</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104545854.png" alt="image-20230326104545854"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104600599.png" alt="image-20230326104600599"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104611381.png" alt="image-20230326104611381"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104628134.png" alt="image-20230326104628134"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104641199.png" alt="image-20230326104641199"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104719928.png" alt="image-20230326104719928"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104728292.png" alt="image-20230326104728292"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104735895.png" alt="image-20230326104735895"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104745797.png" alt="image-20230326104745797"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104835843.png" alt="image-20230326104835843"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104844811.png" alt="image-20230326104844811"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104853689.png" alt="image-20230326104853689"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326104910827.png" alt="image-20230326104910827"></p>
<h2 id="红黑树（RBT）"><a href="#红黑树（RBT）" class="headerlink" title="红黑树（RBT）"></a>红黑树（RBT）</h2><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230425104429101.png" alt="image-20230425104429101"></p>
<p>&#x3D;&#x3D;平衡二叉树AVL&#x3D;&#x3D;:插入&#x2F;删除很容易破坏“平衡”特性，需要频繁调整树的形态。如:插入操作导致不平衡，则需要&#x3D;&#x3D;先计算平衡因子，找到最小不平衡子树(时间开销大)&#x3D;&#x3D;，再进行LL&#x2F;RR&#x2F;LR&#x2F;RL调整<br>红黑树RBT:插入&#x2F;删除很多时候不会破坏“红黑”特性，无需频繁调整树的形态。即便需要调整，一般都可以&#x3D;&#x3D;在常数级时间内完成&#x3D;&#x3D;</p>
<blockquote>
<p>平衡二叉树：适用于以查为主、很少插入&#x2F;删除的场景<br>红黑树：适用于频繁插入、删除的场景，实用性更强</p>
</blockquote>
<h3 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h3><p>&#x3D;&#x3D;红黑树是二叉排序树$\longrightarrow$左子树结点值≤根结点值≤右子树结点值&#x3D;&#x3D;<br>与普通BST相比，有什么要求：</p>
<ol>
<li>每个结点或是红色，或是黑色的</li>
<li>根节点是黑色的</li>
<li>叶结点( <em>外部结点、NULL结点、失败结点</em>)均是黑色的</li>
<li>不存在两个相邻的红结点(即红结点的父节点和孩子结点均是黑色)</li>
<li>对每个结点，从该节点到任一叶结点的简单路径上，所含黑结点的数目相同</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RBnode</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    RBnode *parent;</span><br><span class="line">    RBnode *lChild;</span><br><span class="line">    RBnode *rChild;</span><br><span class="line">    <span class="type">int</span> color;	<span class="comment">//节点颜色，如0/1表示 黑/红，也可用枚举型enum表示颜色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>左根右，根叶黑，不红红，路黑同</p>
</blockquote>
<p>补充概念：节点的“黑高”</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230425110708608.png" alt="image-20230425110708608"></p>
<blockquote>
<p>结点的黑高bh——从某结点出发(不含该结点)到一空叶结点的路径上黑结点总数</p>
<p>根节点黑高为h的红黑树，内部节点数（关键字）至少有多少个？</p>
<p>内部节点数&#x3D;&#x3D;最少&#x3D;&#x3D;的情况——总共h层黑节点的满树形态</p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230425123418345.png" alt="image-20230425123418345" style="zoom: 67%;">

<p><em>结论：若根结点黑高为h，内部根结点数（关键字）最少有2^h^-1个</em></p>
</blockquote>
<h3 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h3><p><strong>性质1:从根节点到叶结点的最长路径不大于最短路径的2倍</strong>$\longrightarrow$<em>任一节点左子树和右子树高度之差不超过两倍</em></p>
<p><strong>性质2:有n个内部节点的红黑树高度<em>h ≤ 2log<del>2</del>(n+ 1)</em></strong>$\longrightarrow$<em>红黑树查找操作时间复杂度&#x3D; O(log<del>2</del>n)</em></p>
<blockquote>
<p>性质1证明：任何一.条查找失败路径上黑结点数量都相同，而路径上不能连续出现两个红结点，即红结点只能穿插在各个黑结点中间</p>
<p>性质2证明：若<em>红黑树总高度h</em>，则<em>根黑高≥h&#x2F;2</em>，因此<em>内部结点树 n ≥ 2^h&#x2F;2^-1</em>，由此推出<em>h ≤ 2log<del>2</del>(n+1)</em></p>
</blockquote>
<blockquote>
<p>查找效率与AVL树同等数量级</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230425111346159.png" alt="image-20230425111346159"></p>
<h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230425115903699.png" alt="image-20230425115903699"></p>
<blockquote>
<p>非根节点的插入只需要检测是否违反&#x3D;&#x3D;“不红红”&#x3D;&#x3D;</p>
</blockquote>
<blockquote>
<p>演示网站：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">Red&#x2F;Black Tree Visualization (usfca.edu)</a></p>
</blockquote>
<h3 id="红黑树的删除（基本不考）"><a href="#红黑树的删除（基本不考）" class="headerlink" title="红黑树的删除（基本不考）"></a>红黑树的删除（基本不考）</h3><p>重要考点:<br>①红黑树删除操作的&#x3D;&#x3D;时间复杂度&#x3D;O(log<del>2</del>n)&#x3D;&#x3D;<br>②在红黑树中删除结点的处理方式和“&#x3D;&#x3D;二叉排序树的删除&#x3D;&#x3D;”一样<br>③按②删除结点后，可能破坏“红黑树特性”，此时需要调整结点颜色、位置，使其再次满<br>足“红黑树特性。</p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h3 id="B树的定义"><a href="#B树的定义" class="headerlink" title="B树的定义"></a>B树的定义</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516161220804.png" alt="image-20230516161220804"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516162026161.png" alt="image-20230516162026161"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516162048726.png" alt="image-20230516162048726"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516162242554.png" alt="image-20230516162242554"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516162419490.png" alt="image-20230516162419490"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516162443911.png" alt="image-20230516162443911"></p>
<p>&#x3D;&#x3D;B树&#x3D;&#x3D;，又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵<em>m阶B树</em>或为空树，或为满足如下特性的m叉树:</p>
<ol>
<li>树中每个结点至多有m棵子树，即至多含有m-1个关键空。</li>
<li>若根结点还是终端结杰、则至少有两棵子树。</li>
<li><em>除根结点外</em>的所有非叶结点<em>至少有「m&#x2F;2]棵子树</em>，即至少含有*[m&#x2F;2]-1个关键字*。</li>
<li>所有的<em>叶结点</em>都出现在同一层次上，并且不带信息（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空)。</li>
</ol>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516163220788.png" alt="image-20230516163220788"></p>
<p>其中，Ki (i&#x3D; 1,2…, n)为结点的关键字，且满足<em>K1&lt;K2&lt;…&lt; Kn</em>；Pi (i &#x3D; 0,1..， n)为指向子树根结点的指针，且指针<em>Pi-1所指子树中所有结点的关键字均小于Ki</em>，<em>Pi所指子树中所有结点的关键字均大于Ki</em>，n( [m&#x2F;2]-1≤n≤m -1)为结点中关键字的个数。</p>
<blockquote>
<p>&#x3D;&#x3D;m阶B树的核心特性:&#x3D;&#x3D;</p>
<ol>
<li>根节点的子树数∈[2, m]，关键字数∈[1, m-1]。</li>
<li>其他结点的子树数∈[ [m&#x2F;2], m];关键字数∈[[m&#x2F;2]-1, m-1]2)</li>
<li>对任一结点，其所有子树高度都相同</li>
<li>关键字的值:子树O&lt;关键字1&lt;子树1&lt;关键字2&lt;子树2&lt;…..(类比二叉查找树左&lt;中&lt;右)</li>
</ol>
</blockquote>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516163827595.png" alt="image-20230516163827595" style="zoom:80%;">

<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516163852287.png" alt="image-20230516163852287" style="zoom:80%;">

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516164309478.png" alt="image-20230516164309478"></p>
<h3 id="B树的插入删除"><a href="#B树的插入删除" class="headerlink" title="B树的插入删除"></a>B树的插入删除</h3><p><strong>插入</strong></p>
<p>核心要求</p>
<ol>
<li><p>对m阶B树——除根节点外，结点关键字个数$\lceil m&#x2F;2 \rceil$-1≤n≤m-1</p>
</li>
<li><p>子树O&lt;关键字1&lt;子树1&lt;关键字2&lt;子树2&lt;….</p>
</li>
</ol>
<p>新元素一定是插入到最底层“终端节点”，用“查找”来确定插入位置<br>在插入key后，若导致原结点关键字数超过上限，则从中间位置([m&#x2F;2]）将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（[m&#x2F;2])的结点插入原结点的父结点。若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增1。</p>
<p><strong>删除</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516170744384.png" alt="image-20230516170744384"></p>
<blockquote>
<p>核心要求：</p>
<ol>
<li>对m阶B树——除根节点外，关键字节点个数$\lceil m&#x2F;2 \rceil$-1≤n≤m-1</li>
<li>子树0&lt;关键字&lt;子树1&lt;关键字2&lt;子树2&lt;……</li>
</ol>
</blockquote>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516172742674.png" alt="image-20230516172742674"></p>
<blockquote>
<p>一棵m阶的B+树需满足下列条件:</p>
<ol>
<li>每个分支结点最多有m棵子树(孩子结点)。</li>
<li>非叶根结点至少有两棵子树，其他每个分支结点至少有「m&#x2F;2]棵子树。</li>
<li><em>结点的子树个数与关键字个数相等。</em></li>
<li>所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且*相邻叶结点按大小顺序相互链接起来(支持顺序查找)*。</li>
<li>所有分支节点中仅包含它子节点中的<em>关键字的最大值</em>及指向其子节点的指针</li>
</ol>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516172036273.png" alt="image-20230516172036273"></p>
<blockquote>
<p>可以理解为:要追求“绝对平衡”，即所有子树高度要相同</p>
<p><em>非叶节点至少有两颗子树</em>，其他每个分支节点至少有$\lceil m&#x2F;2 \rceil$棵子树</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516180409691.png" alt="image-20230516180409691"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516180621243.png" alt="image-20230516180621243"></p>
<table>
<thead>
<tr>
<th align="center">B+树</th>
<th align="center">B树</th>
</tr>
</thead>
<tbody><tr>
<td align="center">结点中的n个关键字对应 n 棵树</td>
<td align="center">结点中的n个关键字对应 n+1 棵树</td>
</tr>
<tr>
<td align="center">根结点的关键字数n$\in$[1,m]          其它节点的关键字数n$\in$[  $\lceil m&#x2F;2 \rceil$,m  ]</td>
<td align="center">根结点的关键字数n$\in$[1,m-1]          其它节点的关键字数n$\in$[  $\lceil m&#x2F;2 \rceil$-1,m-1  ]</td>
</tr>
<tr>
<td align="center">叶结点包含全部关键字，非叶结点中出现过的关键字也会出现在叶结点中</td>
<td align="center">在B树中，各结点中包含的关键字是不重复的</td>
</tr>
<tr>
<td align="center">叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</td>
<td align="center">B树的结点中都包含了关键字对应的记录的存储地址</td>
</tr>
</tbody></table>
<blockquote>
<p>在B+树中，<em>非叶结点不含有该关键字对应记录的存储地址。</em></p>
<p>可以使一个磁盘块可以包含更多个关键字，使得B+树的阶更大，<em>树高更矮，</em></p>
<p><em>读磁盘次数更少，查找更快</em></p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230516182528933.png" alt="image-20230516182528933"></p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>带权路径长度</p>
<p>结点的权：有某种现实含义的数值（如：表示结点的重要性等） </p>
<p>&#x3D;&#x3D;结点的带权路径长度&#x3D;&#x3D;：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积 </p>
<p>&#x3D;&#x3D;树的带权路径长度&#x3D;&#x3D;：树中所有&#x3D;&#x3D;叶结点&#x3D;&#x3D;的带权路径长度之和</p>
<h3 id="哈夫曼树的定义"><a href="#哈夫曼树的定义" class="headerlink" title="哈夫曼树的定义"></a>哈夫曼树的定义</h3><p>在含有n个带权叶结点的二叉树中，其中&#x3D;&#x3D;带权路径长度（WPL）最小&#x3D;&#x3D;的二叉树称为哈夫曼树，也称&#x3D;&#x3D;最优二叉树&#x3D;&#x3D;</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326105121132.png" alt="image-20230326105121132"></p>
<h3 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h3><p>给定n个权值分别为w1, w2,…, wn的结点，构造哈夫曼树的算法描述如下： </p>
<ol>
<li>将这n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。 </li>
<li>构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新 结点的权值置为左、右子树上根结点的权值之和。</li>
<li>从F中删除刚才选出的两棵树，同时将新得到的树加入F中。 </li>
<li>重复步骤 2 和 3 ，直至F中只剩下一棵树为止。</li>
</ol>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326105306155.png" alt="image-20230326105306155"></p>
<blockquote>
<ol>
<li>每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大 </li>
<li>哈夫曼树的结点总数为2n − 1 </li>
<li>哈夫曼树中不存在度为1的结点。 </li>
<li>哈夫曼树并不唯一，但WPL必然相同且为最优</li>
</ol>
</blockquote>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>&#x3D;&#x3D;可变长度编码&#x3D;&#x3D;——允许对不同字符用不等长的二进制位表示</p>
<p>若没有一个编码是另一个编码的前缀，则称这样的编码为 &#x3D;&#x3D;前缀编码&#x3D;&#x3D;</p>
<p>固定长度编码- –每个字符用相等长度的二进制位表示<br>可变长度编码–允许对不同字符用不等长的二进制位表示<br>若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码<br>有哈夫曼树得到哈夫曼编码- –字符集中的每个字符作为-一个叶子结点，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326105605706.png" alt="image-20230326105605706"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326105615754.png" alt="image-20230326105615754"></p>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="并查集基础"><a href="#并查集基础" class="headerlink" title="并查集基础"></a>并查集基础</h3><p>用互不相交的树，表示多个“集合”</p>
<p>对这些“集合”进行查询和合并操作得到的集合：并查集</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326115419871.png" alt="image-20230326115419871"></p>
<p>如何“查”到一个元素到底属于哪一个集 合?</p>
<p><strong>从指定元素出发，一路向北，找到根节点</strong></p>
<p>如何判断两个元素是否属于同一个集合?</p>
<p><strong>分别查到两个元素的根，判断根节点是否相同即可</strong></p>
<p>如何把两个集合“并”为一一个集合?</p>
<p><strong>让一棵树成为另一棵树的子树即可</strong></p>
<p>为了进行“查询”和“并”操作，这里选择树的存储结构为&#x3D;&#x3D;双亲表示法&#x3D;&#x3D;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双亲表示法:每个结点中保存指向双亲的“指针”</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ TREE_ _SIZE 100	<span class="comment">//树中最多结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;	<span class="comment">//树的结点定义</span></span><br><span class="line">    ElemType data; 	<span class="comment">//数据元素</span></span><br><span class="line">    <span class="type">int</span> parent;	<span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;	<span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes [MAX_ TREE_ _SIZE] ;	<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n;	<span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326115936959.png" alt="image-20230326115936959"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="type">int</span> UFSets[SIZE];<span class="comment">//集合元素数组</span></span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initial</span><span class="params">(<span class="type">int</span> S[ ])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)</span><br><span class="line">        S[i]=<span class="number">-1</span> ;   <span class="comment">//将S[]全部初始化为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find &quot;查&quot;操作， 找x所属集合(返回x所属根结点)</span></span><br><span class="line"><span class="comment">//最坏时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span> )	<span class="comment">//循环寻找x的根</span></span><br><span class="line">        x=S[x];</span><br><span class="line">    <span class="keyword">return</span> X;	<span class="comment">//根的S[ ]小于0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Union &quot;并&quot;操作， 将两个集合合并为-个</span></span><br><span class="line"><span class="comment">//时间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1, <span class="type">int</span> Root2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//要求Root1与Root2是不同的集合</span></span><br><span class="line">    <span class="keyword">if</span> (Root1==Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将根Root2连接到另一根Root1下面</span></span><br><span class="line">    S[Root2]=Root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a>并查集的优化</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326120447989.png" alt="image-20230326120447989"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Union“并&quot; 操作，小树合并到大树</span></span><br><span class="line"><span class="comment">//该方法构造的树高不超过[log2n]+ 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[ ],<span class="type">int</span> Root1, <span class="type">int</span> Root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( Root1==Root2 )</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(S[Root2]&gt;S[Root1]) &#123; <span class="comment">//Root2结点数更少</span></span><br><span class="line">        S[Root1] += S[Root2]; <span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root2]=Root1; <span class="comment">//小树合并到大树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        S[Root2] += S[Root1]; <span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root1]=Root2; / /小树合并到大树</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Union优化后，find的最坏时间复杂度变为O(log<del>2</del>n)</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326120917411.png" alt="image-20230326120917411"></p>
<h3 id="并查集进一步优化"><a href="#并查集进一步优化" class="headerlink" title="并查集进一步优化"></a>并查集进一步优化</h3><p>Find的优化（压缩路径）</p>
<p>压缩路径—— Find 操作，先找到根节点，再将查找路径上所有结点都挂到根结点下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find“查&quot;操作优化，(先找到根节点再进行“压缩路径”</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span>(S[root]&gt;=<span class="number">0</span>)</span><br><span class="line">        root=S[root]; <span class="comment">//循环找到根</span></span><br><span class="line">    <span class="keyword">while</span>(x!=root)&#123; <span class="comment">//压缩路径</span></span><br><span class="line">        <span class="type">int</span> t=S[x];	<span class="comment">// t指向x的父节点</span></span><br><span class="line">        S[x]=root ;	<span class="comment">//x直接挂到根节点下</span></span><br><span class="line">        x=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root ;/ /返回根节点编号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326121408068.png" alt="image-20230326121408068" style="zoom:80%;">

<p>每次Find操作，先找根，再“压缩路径”，可使树的高度不超过0(a(n))。a(n)是一个 增长很缓慢的函数，对于常见的n值，通常a(n)S4， 因此优化后并查集的Find、Union操 作时间开销都很低</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230326121531271.png" alt="image-20230326121531271"></p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>&#x3D;&#x3D;图G&#x3D;&#x3D;由&#x3D;&#x3D;顶点集V&#x3D;&#x3D;和&#x3D;&#x3D;边集E&#x3D;&#x3D;组成，记为G &#x3D; (V, E)，其中V(G)表示图G中顶点的有限非空集；E(G) 表示图G中顶点之间的关系（边）集合。若V &#x3D; {v1, v2, … , vn}，则用<code>|V|</code>表示&#x3D;&#x3D;图G中顶点的个数&#x3D;&#x3D;，也称&#x3D;&#x3D;图G的阶&#x3D;&#x3D;，E &#x3D; {(u, v) | uÎV, vÎV}，用<code>|E|</code>表示&#x3D;&#x3D;图G中边的条数&#x3D;&#x3D;。 </p>
<p> 注意：线性表可以是空表，树可以是空树，但图不可以是空，即&#x3D;&#x3D;V一定是非空集&#x3D;&#x3D;</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328210546603.png" alt="image-20230328210546603"></p>
<p><strong>无向图、有向图</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328210748443.png" alt="image-20230328210748443"></p>
<p>若E是&#x3D;&#x3D;无向边&#x3D;&#x3D;（简称边）的有限集合时，则图G为&#x3D;&#x3D;无向图&#x3D;&#x3D;。边 是顶点的无序对，记为&#x3D;&#x3D;(v, w)或(w, v)&#x3D;&#x3D;，因为&#x3D;&#x3D;(v, w) &#x3D; (w, v)&#x3D;&#x3D;，其 中v、w是顶点。可以说顶点w和顶点v互为邻接点。边(v, w) 依附于顶点w和v，或者说边(v, w)和顶点v、w相关联。 G2 &#x3D; (V2, E2) V2 &#x3D; {A, B, C, D, E} E2 &#x3D; {(A, B), (B, D), (B, E), (C, D), (C, E), (D, E)}</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328211103605.png" alt="image-20230328211103605"></p>
<p>若E是&#x3D;&#x3D;有向边&#x3D;&#x3D;（也称弧）的有限集合时，则图G为&#x3D;&#x3D;有向图&#x3D;&#x3D;。 弧是顶点的有序对，记为<code>&lt;v,w&gt;</code>，其中v、w是顶点，v称为 弧尾，w称为弧头，称为从顶点v到顶点w的弧，也称 v邻接到w，或w邻接自v。  <code>&lt;v,w&gt;≠&lt;w,v&gt;</code>  G1 &#x3D; (V1, E1) V1 &#x3D; {A, B, C, D, E} E1&#x3D;{&lt;A, B&gt;, &lt;A, C&gt;, &lt;A,D&gt;, &lt;A, E&gt;, &lt;B, A&gt;, &lt;B,C&gt;,&lt;B,E&gt;, &lt;C, D&gt;}</p>
<p><strong>简单图、多重图</strong></p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328211147062.png" alt="image-20230328211147062" style="zoom:80%;">

<p>简单图——① 不存在重复边； ② 不存在顶点到自身的边</p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328211212080.png" alt="image-20230328211212080" style="zoom:80%;">

<p>多重图——图G中某两个结点之间的边数多于 一条，又允许顶点通过同一条边和自己关联， 则G为多重图</p>
<p><strong>顶点的度、入度、出度</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328211848477.png" alt="image-20230328211848477"></p>
<p>对于&#x3D;&#x3D;无向图&#x3D;&#x3D;：&#x3D;&#x3D;顶点v的度&#x3D;&#x3D;是指依附于该顶点的边的条数，记为TD(v)。 </p>
<blockquote>
<p>在具有n个顶点、e条边的无向图中， $\sum_{i&#x3D;1}^n$TD(v<del>i</del>) &#x3D; 2e</p>
<p>&#x3D;&#x3D;即无向图的全部顶点的度的和等于边数的2倍&#x3D;&#x3D;</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328211856740.png" alt="image-20230328211856740"></p>
<p>对于有向图： </p>
<p>&#x3D;&#x3D;入度&#x3D;&#x3D;是以顶点v为终点的有向边的数目，记为ID(v)； </p>
<p>&#x3D;&#x3D;出度&#x3D;&#x3D;是以顶点v为起点的有向边的数目，记为OD(v)。 </p>
<blockquote>
<p>顶点v的度等于其&#x3D;&#x3D;入度和出度之和&#x3D;&#x3D;，即TD(v) &#x3D; ID(v) + OD(v)。 </p>
<p>在具有n个顶点、e条边的有向图中，$\sum_{i&#x3D;1}^n$ID(v<del>i</del>) &#x3D; $\sum_{i&#x3D;1}^n$TD(v<del>i</del>) &#x3D; e</p>
</blockquote>
<p><strong>顶点-顶点的关系描述</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328212356530.png" alt="image-20230328212356530"></p>
<ul>
<li><strong>路径</strong>——顶点vp到顶点vq之间的一条路径是指顶点序列 </li>
<li><strong>回路—</strong>—第一个顶点和最后一个顶点相同的路径称为回路或环 </li>
<li><strong>简路径—</strong>—在路径序列中，顶点不重复出现的路径称为简单路径。</li>
<li><strong>简单回路—</strong>—除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。 </li>
<li><strong>路径长度</strong>——路径上边的数目 </li>
<li><strong>点到点的距离—</strong>—从顶点u出发到顶点v的最&#x3D;&#x3D;短路径若&#x3D;&#x3D;存在，则此路径的长度称为从u到v的距离。 若从u到v根本&#x3D;&#x3D;不存在路径&#x3D;&#x3D;，则记该距离为无穷（∞）。</li>
<li>无向图中，若从顶点v到顶点w有路径存在，则称v和w是&#x3D;&#x3D;连通&#x3D;&#x3D;的 </li>
<li>有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强&#x3D;&#x3D;连通的&#x3D;&#x3D;</li>
</ul>
<p><strong>连通图、强连通图</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328212518537.png" alt="image-20230328212518537"></p>
<p>若图G中任意两个顶点都是连通的，则称图G为 &#x3D;&#x3D;连通图&#x3D;&#x3D;，否则称为&#x3D;&#x3D;非连通图&#x3D;&#x3D;。 </p>
<p>若图中任何一对顶点都是强连通的，则称此图为强连通图。 </p>
<blockquote>
<p>常见考点： </p>
<ol>
<li>对于n个顶点的&#x3D;&#x3D;无向图&#x3D;&#x3D;G， 若G是&#x3D;&#x3D;连通图&#x3D;&#x3D;，则&#x3D;&#x3D;最少&#x3D;&#x3D;有 &#x3D;&#x3D;n-1&#x3D;&#x3D; 条边 ；若G是&#x3D;&#x3D;非连通图&#x3D;&#x3D;，则&#x3D;&#x3D;最多&#x3D;&#x3D;可能有&#x3D;&#x3D;<strong>C<del>n-1</del>^2^</strong>&#x3D;&#x3D; 条边</li>
<li>对于n个顶点的&#x3D;&#x3D;有向图&#x3D;&#x3D;G， 若G是&#x3D;&#x3D;强连通图&#x3D;&#x3D;，则&#x3D;&#x3D;最少&#x3D;&#x3D;有 &#x3D;&#x3D;n&#x3D;&#x3D; 条边（形成回路）</li>
</ol>
</blockquote>
<p><strong>研究图的局部——子图</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328213018013.png" alt="image-20230328213018013"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328213031555.png" alt="image-20230328213031555"></p>
<p><strong>连通分量</strong></p>
<p>无向图中的&#x3D;&#x3D;极大连通子图&#x3D;&#x3D;称为&#x3D;&#x3D;连通分量&#x3D;&#x3D;。（子图必须连通，且包含 尽可能多的顶点和边）</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328213123956.png" alt="image-20230328213123956"></p>
<p><strong>强连通分量</strong></p>
<p>有向图中的&#x3D;&#x3D;极大强连通子图&#x3D;&#x3D;称为有向图的&#x3D;&#x3D;强连通分量&#x3D;&#x3D;（子图必须强连通，同时 保留尽可能多的边）</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328213243055.png" alt="image-20230328213243055"></p>
<p><strong>生成树</strong></p>
<p>连通图的&#x3D;&#x3D;生成树&#x3D;&#x3D;是包含图中&#x3D;&#x3D;全部顶点&#x3D;&#x3D;的一个&#x3D;&#x3D;极小连通子图&#x3D;&#x3D;。</p>
<p> 若图中顶点数为n，则它的生成树含有 &#x3D;&#x3D;n-1&#x3D;&#x3D; 条边。对生成树而言，<strong>若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路</strong>。（边尽可能的少， 但要保持连通）</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328213503543.png" alt="image-20230328213503543"></p>
<p><strong>生成森林</strong></p>
<p>在&#x3D;&#x3D;非连通图&#x3D;&#x3D;中，&#x3D;&#x3D;连通分量的生成树&#x3D;&#x3D;构成了非连通图的&#x3D;&#x3D;生成森林&#x3D;&#x3D;。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328213643237.png" alt="image-20230328213643237"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328213700704.png" alt="image-20230328213700704"></p>
<p><strong>边的权、带权图&#x2F;网</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328213827113.png" alt="image-20230328213827113"></p>
<p><strong>边的权</strong>——在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。</p>
<p> <strong>带权图&#x2F;网—</strong>—边上带有权值的图称为带权图，也称网。 </p>
<p><strong>带权路径长度</strong>——当图是带权图时，<strong>一条路径上所有边的权值之和</strong>，称为该路径的带权路径长度</p>
<h3 id="几种特殊形态的图"><a href="#几种特殊形态的图" class="headerlink" title="几种特殊形态的图"></a>几种特殊形态的图</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328213906324.png" alt="image-20230328213906324"></p>
<p>&#x3D;&#x3D;无向完全图&#x3D;&#x3D;——无向图中任意两个顶点 之间都存在边 </p>
<p>若无向图的顶点数|V|&#x3D;n，则 |E| ∈ [0, &#x3D;&#x3D;C<del>n</del>^2^&#x3D;&#x3D;] &#x3D; [0, &#x3D;&#x3D;n(n–1)&#x2F;2&#x3D;&#x3D;]</p>
<p>&#x3D;&#x3D;有向完全图&#x3D;&#x3D;——有向图中任意两个顶点 之间都存在方向相反的两条弧 </p>
<p>若有向图的顶点数|V|&#x3D;n，则 |E| ∈ 0, &#x3D;&#x3D;2C<del>n</del>^2^&#x3D;&#x3D;] &#x3D; [0, &#x3D;&#x3D;n(n–1)&#x3D;&#x3D;]</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328214122002.png" alt="image-20230328214122002"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328214142796.png" alt="image-20230328214142796"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230328214157089.png" alt="image-20230328214157089"></p>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329215026983.png" alt="image-20230329215026983"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100	<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> Vex[MaxVertexNum] ;	<span class="comment">//顶点表.（顶点中可以存更复杂的信息）</span></span><br><span class="line">    <span class="type">int</span> Edge [MaxVertexNum] [MaxVertexNum];	<span class="comment">//邻接矩阵，边表（可以用 bool型或枚举型变量表示边）</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;		<span class="comment">//图的当前顶点数和边数/弧数</span></span><br><span class="line">&#125; MGraph;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329215259270.png" alt="image-20230329215259270"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329215419072.png" alt="image-20230329215419072"></p>
<p><strong>邻接矩阵法存储带权图（网）</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329215542427.png" alt="image-20230329215542427"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100	<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 最大的int值 <span class="comment">//宏定义常量&quot;无穷&quot;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VertexType; 	<span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> EdgeType;		<span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    VertexType Vex [MaxVertexNum];	<span class="comment">//顶点</span></span><br><span class="line">    EdgeType Edge [MaxVertexNum] [MaxVertexNum]; <span class="comment">//边的权</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;		<span class="comment">// 图的当前顶点数和弧数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>

<p>有时也会将同顶点的路径权值改为0</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329215815612.png" alt="image-20230329215815612"></p>
<p><strong>邻接矩阵法的性能分析</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329215900687.png" alt="image-20230329215900687"></p>
<p>空间复杂度：O(|V|^2^ ) ——只和顶点数相关，和实际的边数无关 </p>
<blockquote>
<p>&#x3D;&#x3D;顶点数为n，则其空间复杂度为O(n) + O(n^2^) ，即为 O(n^2^)&#x3D;&#x3D;</p>
</blockquote>
<p>适合用于存储稠密图 </p>
<p>无向图的邻接矩阵是对称矩阵，可以压缩存储（只存储上三角区&#x2F;下三角区）</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329220202838.png" alt="image-20230329220202838"></p>
<p><strong>邻接矩阵法的性质</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329220242940.png" alt="image-20230329220242940"></p>
<blockquote>
<p>比如&#x3D;&#x3D;A^2^&#x3D;&#x3D;<code>[1][4]</code>就表示从A到D，长度为2的路径数目</p>
<p>其中 &#x3D;&#x3D;a<del>1</del>,<del>1</del> a<del>1</del>,<del>4</del>&#x3D;&#x3D; 表示A——&gt;A(0) 和 A——&gt;D(0) 路径的合并，0*0 &#x3D; 0 故没有这样的路径</p>
<p>再如&#x3D;&#x3D;a<del>1</del>,<del>2</del>  a<del>2</del>,<del>4</del>&#x3D;&#x3D; 表示A——&gt;B(1) 和 B——&gt;D(1) 路径的合并，1*1 &#x3D; 1 故有一条A——&gt;B——&gt;D的路径</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329221106332.png" alt="image-20230329221106332"></p>
<blockquote>
<p>&#x3D;&#x3D;A^3^&#x3D;&#x3D; 和上述法则相同，表示X——&gt;X路径长度为&#x3D;&#x3D;3&#x3D;&#x3D;的路径的数量</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329221245683.png" alt="image-20230329221245683"></p>
<h3 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h3><p><strong>邻接表法（顺序+链式存储）</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329222527443.png" alt="image-20230329222527443"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;</span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;边/弧&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> adivex;		<span class="comment">//边/弧指向哪个结点</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *next ;	<span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType. info;	//边权值</span></span><br><span class="line">&#125;ArcNode;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&quot;顶点&quot;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span>&#123;</span><br><span class="line">    VertexType data;	<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;		<span class="comment">//第一条边/弧</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br></pre></td></tr></table></figure>

<p><strong>对比：树的孩子表示法</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329222915709.png" alt="image-20230329222915709"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329223026598.png" alt="image-20230329223026598"></p>
<blockquote>
<p>求顶点的度：</p>
<p>无向图：遍历与顶点相关的边链表，有多少边节点就有多少个度</p>
<p>有向图：</p>
<p>出度：遍历与顶点相关的边链表，有多少边节点就有多少个出度</p>
<p>入度：全部进行遍历，找到指向顶点的 （时间复杂度高）</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329223424539.png" alt="image-20230329223424539"></p>
<blockquote>
<p>&#x3D;&#x3D;图的邻接表表示 方式并不唯一&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;只要确定了顶 点编号，图的 邻接矩阵表示 方式唯一&#x3D;&#x3D;</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230329223518228.png" alt="image-20230329223518228"></p>
<table>
<thead>
<tr>
<th></th>
<th>邻接表</th>
<th>邻接矩阵</th>
</tr>
</thead>
<tbody><tr>
<td>空间复杂度</td>
<td>无向图 O(|V| + 2|E|）;有向图O(|V| + |E|)</td>
<td>O(|V|^2^)</td>
</tr>
<tr>
<td>适存合用于</td>
<td>存储稀疏图</td>
<td>存储稠密图</td>
</tr>
<tr>
<td>表示方式</td>
<td>不唯一</td>
<td>唯一</td>
</tr>
<tr>
<td>计算度&#x2F;出度&#x2F;入度</td>
<td>计算有向图的度、入度不方便，其余很方便</td>
<td>必须遍历对应行或列</td>
</tr>
<tr>
<td>找相邻的边</td>
<td>找有向图的入边不方便，其余很方便</td>
<td>必须遍历对应行或列</td>
</tr>
</tbody></table>
<h3 id="邻接矩阵、邻接表存储有向图："><a href="#邻接矩阵、邻接表存储有向图：" class="headerlink" title="邻接矩阵、邻接表存储有向图："></a><strong>邻接矩阵、邻接表存储有向图：</strong></h3><p>对于邻接表：&#x3D;&#x3D;找有向图的入边不方便&#x3D;&#x3D; ；对邻接矩阵：&#x3D;&#x3D;空间复杂度 高 O(|V|^2^)&#x3D;&#x3D;</p>
<p><strong>十字链表存储&#x3D;&#x3D;有向图&#x3D;&#x3D;</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230330110932736.png" alt="image-20230330110932736"></p>
<p>空间复杂度：&#x3D;&#x3D;O(|V|+|E|)&#x3D;&#x3D; </p>
<p>如何找到指定顶点的所有出边？——顺着绿色线路找 </p>
<p>如何找到指定顶点的所有入边？——顺着橙色线路找 </p>
<blockquote>
<p>注意：十字链表只用于存储有向图</p>
</blockquote>
<p><strong>邻接矩阵、邻接表存储无向图：</strong></p>
<p>邻接表：&#x3D;&#x3D;每条边对应两份冗余信息&#x3D;&#x3D;， 删除顶点、删除边等操作&#x3D;&#x3D;时间复杂度高&#x3D;&#x3D;</p>
<p>邻接矩阵：&#x3D;&#x3D;空间复杂度高 O(|V|2 )&#x3D;&#x3D;</p>
<p><strong>邻接多重表存储&#x3D;&#x3D;无向图&#x3D;&#x3D;：</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230330111405181.png" alt="image-20230330111405181"></p>
<p>空间复杂度：&#x3D;&#x3D;O(|V|+|E|)&#x3D;&#x3D; </p>
<p>删除边、删除节点等操作很方便 （每条边只对应一份数据）</p>
<blockquote>
<p>注意：邻接多重表只适用于存储无向图</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230330111614701.png" alt="image-20230330111614701"></p>
<table>
<thead>
<tr>
<th></th>
<th>邻接矩阵</th>
<th>邻接表</th>
<th>十字链表</th>
<th>邻接多重表</th>
</tr>
</thead>
<tbody><tr>
<td>空间复杂度</td>
<td>O(|V|^2^)</td>
<td>无向图O(|V|+2|E|) ;有向图O(|V|+|E|)</td>
<td>O(|V|+|E|)</td>
<td>O(|V|+|E|)</td>
</tr>
<tr>
<td>找相邻边</td>
<td>遍历对应行或列 时间复杂度为O(|V|)</td>
<td>找有向图的入边必须遍 历整个邻接表</td>
<td>很方便</td>
<td>很方便</td>
</tr>
<tr>
<td>删除边或顶点</td>
<td>删除边很方便，删除顶 点需要大量移动数据</td>
<td>无向图中删除边或顶点 都不方便</td>
<td>很方便</td>
<td>很方便</td>
</tr>
<tr>
<td>适用于</td>
<td>稠密图</td>
<td>稀疏图和其他</td>
<td>只能存有向图</td>
<td>只能存无向图</td>
</tr>
<tr>
<td>表示方式</td>
<td>唯一</td>
<td>不唯一</td>
<td>不唯一</td>
<td>不唯一</td>
</tr>
</tbody></table>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>图的基本操作： </p>
<ul>
<li>Adjacent(G,x,y)：判断图G是否存在边或(x, y)或边&lt;x,y&gt;。 </li>
<li>Neighbors(G,x)：列出图G中与结点x邻接的边。 </li>
<li>InsertVertex(G,x)：在图G中插入顶点x。 </li>
<li>DeleteVertex(G,x)：从图G中删除顶点x。 </li>
<li>AddEdge(G,x,y)：若无向边(x, y)或有向边不存在，则向图G中添加该边。 </li>
<li>RemoveEdge(G,x,y)：若无向边(x, y)或有向边存在，则从图G中删除该边。 </li>
<li>*FirstNeighbor(G,x)*：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点 或图中不存在x，则返回-1。 </li>
<li>*NextNeighbor(G,x,y)*：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一 个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。 </li>
<li>Get_edge_value(G,x,y)：获取图G中边(x, y)或对应的权值。 </li>
<li>et_edge_value(G,x,y,v)：设置图G中边(x, y)或对应的权值为v。</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>邻接矩阵</th>
<th>邻接表</th>
</tr>
</thead>
<tbody><tr>
<td>判断图G是否存在边&lt;x,y&gt;或(x, y)</td>
<td>无（有）向图：O(1)</td>
<td>无（有）向图：O(1) ~O(|V|)</td>
</tr>
<tr>
<td>出图G中与结点x邻接的边</td>
<td>无（有）向图：O(|V|)</td>
<td>无向图：O(1) ~O(|V|)；有向图：出边：O(1) ~O(|V|)，入边：O(|E|)</td>
</tr>
<tr>
<td>图G中插入顶点x</td>
<td>无（有）向图：O(1)</td>
<td>无（有）向图：O(1)</td>
</tr>
<tr>
<td>从图G中删除顶点x</td>
<td>无（有）向图：O(|V|)</td>
<td>无向图：O(1) ~O(|E|) ；有向图：删出边：O(1) ~O(|V|)，删入边：O(|E|)</td>
</tr>
<tr>
<td>添加边（若该边不存在）</td>
<td>无（有）向图：O(1)</td>
<td>无（有）向图：O(1)</td>
</tr>
<tr>
<td>删除边（若该边存在）</td>
<td>无（有）向图：O(1)</td>
<td>无（有）向图：O(1) ~O(|V|)</td>
</tr>
<tr>
<td><em>找顶点的下一个邻接点</em></td>
<td>无（有）向图：O(1) ~O(|V|)</td>
<td>无向图：O(1) ；有向图：找出边邻接点：O(1)，<del>找入边邻接点</del>：O(1) ~O(|E|)</td>
</tr>
<tr>
<td><em>找顶点的下一个邻接点x外的下一个邻接点</em></td>
<td>无（有）向图：O(1) ~O(|V|)</td>
<td>无向图：O(1) ；有向图：找出边邻接点：O(1)，<del>找入边邻接点</del>：O(1) ~O(|E|)</td>
</tr>
<tr>
<td>获取边对应的权值；设置边对应的权值为v；（相当于找边）</td>
<td>无（有）向图：O(1)</td>
<td>无（有）向图：O(1) ~O(</td>
</tr>
</tbody></table>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="图的广度优先遍历（BFS）"><a href="#图的广度优先遍历（BFS）" class="headerlink" title="图的广度优先遍历（BFS）"></a>图的广度优先遍历（BFS）</h3><p>树 vs 图</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230401170102248.png" alt="image-20230401170102248"></p>
<p><strong>⼴度优先遍历（Breadth-First-Search, BFS）要点：</strong> </p>
<ol>
<li><p>找到与⼀个顶点相邻的所有顶点 </p>
</li>
<li><p>标记哪些顶点被访问过 </p>
</li>
<li><p>需要⼀个辅助队列</p>
</li>
</ol>
<p>*FirstNeighbor(G,x)*：求图G中顶点x的第⼀个邻接点，若有则返回顶点号。 若x没有邻接点或图中不存在x，则返回-1。</p>
<p>*NextNeighbor(G,x,y)*：假设图G中顶点y是顶点x的⼀个邻接点，返回除y之外 顶点x的下⼀个邻接点的顶点号，若y是x的最后⼀个邻接点，则返回-1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited [MAX_VERTEX_NUM]; <span class="comment">//访问标记数组 (初始都为false)</span></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123; <span class="comment">//从顶点v出发， 广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);	<span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited [v]=TRUE;	<span class="comment">//对v做已访问标记</span></span><br><span class="line">    <span class="built_in">Enqueue</span>(Q,v);	<span class="comment">//顶点v入队列Q .</span></span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);	<span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G, v) ;W&gt;=<span class="number">0</span> ;w=<span class="built_in">NextNeighbor</span>(G,v,W))</span><br><span class="line">            <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited [w])&#123; 	<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);	<span class="comment">//访问顶点w</span></span><br><span class="line">                visited [w]=TRUE;	<span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w); 	<span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230401170913477.png" alt="image-20230401170913477"></p>
<blockquote>
<p>同⼀个图的&#x3D;&#x3D;邻接矩阵&#x3D;&#x3D;表示⽅式&#x3D;&#x3D;唯⼀&#x3D;&#x3D;，因此⼴度优先遍历序列&#x3D;&#x3D;唯⼀&#x3D;&#x3D; </p>
<p>同⼀个图的&#x3D;&#x3D;邻接表&#x3D;&#x3D;表示⽅式&#x3D;&#x3D;不唯⼀&#x3D;&#x3D;，因此⼴度优先遍历序列&#x3D;&#x3D;不唯⼀&#x3D;&#x3D;</p>
</blockquote>
<p><strong>BFS算法（Final版）：解决了非连通图的问题</strong></p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230401171224363.png" alt="image-20230401171224363" style="zoom:67%;">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited [MAX_VERTEX_NUM]; <span class="comment">//访问标记数组 (初始都为false)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123; <span class="comment">//对图G进行广度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;G.vexnum;++i)</span><br><span class="line">        visited[i]=FALSE;	<span class="comment">//访问标记数组初始化</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);	<span class="comment">//初始化辅助队列Q</span></span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;G.vexnum; ++i)	<span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>( !visited[i] )	<span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line">            <span class="built_in">BFS</span>(G,i);	<span class="comment">//vi未访问过，从vi开始BFS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123; <span class="comment">//从顶点v出发， 广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);	<span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited [v]=TRUE;	<span class="comment">//对v做已访问标记</span></span><br><span class="line">    <span class="built_in">Enqueue</span>(Q,v);	<span class="comment">//顶点v入队列Q .</span></span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);	<span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G, v) ;W&gt;=<span class="number">0</span> ;w=<span class="built_in">NextNeighbor</span>(G,v,W))</span><br><span class="line">            <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited [w])&#123; 	<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                <span class="built_in">visit</span>(w);	<span class="comment">//访问顶点w</span></span><br><span class="line">                visited [w]=TRUE;	<span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w); 	<span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：对于⽆向图，调⽤BFS函数的次数&#x3D;连通分量数</p>
</blockquote>
<p><strong>复杂度分析：</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230401171507807.png" alt="image-20230401171507807"></p>
<p>&#x3D;&#x3D;空间复杂度&#x3D;&#x3D;：&#x3D;&#x3D;最坏情况&#x3D;&#x3D;，辅助队列⼤⼩为 &#x3D;&#x3D;O(|V|)&#x3D;&#x3D;</p>
<hr>


<p>&#x3D;&#x3D;邻接矩阵&#x3D;&#x3D;存储的图： </p>
<p>访问 |V| 个顶点需要O(|V|)的时间 </p>
<p>查找每个顶点的邻接点都需要O(|V|)的时间，⽽总共有|V|个顶点 </p>
<p>&#x3D;&#x3D;时间复杂度&#x3D;&#x3D;&#x3D; O(|V|) + O(|V|^2^)   &#x3D; &#x3D;&#x3D;O(|V^2^|)&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;邻接表&#x3D;&#x3D;存储的图： </p>
<p>访问 |V| 个顶点需要O(|V|)的时间 </p>
<p>查找各个顶点的邻接点共需要O(|E|)的时间，（其实对于⽆向图来说，应该是O(2|E|) 的时间）</p>
<p>&#x3D;&#x3D;时间复杂度&#x3D; O(|V|) + O(|E|)&#x3D;&#x3D;</p>
<p><strong>⼴度优先⽣成树</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230401175923696.png" alt="image-20230401175923696"></p>
<p>⼴度优先⽣成树由⼴度优先 遍历过程确定。由于&#x3D;&#x3D;邻接表 的表示⽅式不唯⼀&#x3D;&#x3D;，因此&#x3D;&#x3D;基于邻接表的⼴度优先⽣成树也不唯⼀&#x3D;&#x3D;。</p>
<p>对⾮连通图的⼴度优先遍历，可得到⼴度优先⽣成森林</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230401180020644.png" alt="image-20230401180020644"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230401180118562.png" alt="image-20230401180118562"></p>
<h3 id="图的深度优先遍历（DFS）"><a href="#图的深度优先遍历（DFS）" class="headerlink" title="图的深度优先遍历（DFS）"></a>图的深度优先遍历（DFS）</h3><p>树的深度优先遍历（先根遍历）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>- <span class="built_in">PreOrder</span>(TreeNode *R) &#123;</span><br><span class="line">    <span class="keyword">if</span> (R!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">visit</span>(R);        <span class="comment">//访问根节点</span></span><br><span class="line">        <span class="keyword">while</span>(R还有下一个子树T)<span class="comment">//新找到的相邻结点⼀定是没有访问过的</span></span><br><span class="line">            <span class="built_in">PreOrder</span>(T); <span class="comment">//先根遍历下- -棵子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>树的深度优先遍历（先根、后根）： 从根节点出发，能往更深处⾛就尽量往 深处⾛。每当访问⼀个结点的时候，要 检查是否还有与当前结点相邻的且没有 被访问过的结点，如果有的话就往下⼀ 层钻。 图的深度优先遍历类似于树的先根遍 历。</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230402111225494.png" alt="image-20230402111225494"></p>
<p>先根遍历序列：1，2，5，6，3，4，7，8</p>
<p><strong>图的深度优先遍历</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited [MAX_ _VERTEX_ NUM] ; <span class="comment">//访问标记数组，初始为false</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;	<span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);	<span class="comment">//访问顶点V</span></span><br><span class="line">    visited [v]=TRUE;	<span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span> (w=F irstNe <span class="built_in">ighbor</span>(G, v);w&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighor</span>(G,v,w)) .</span><br><span class="line">        <span class="keyword">if</span>( !visited [w])&#123; 	<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G,w) ;</span><br><span class="line">        &#125; <span class="comment">//if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230402111654484.png" alt="image-20230402111654484"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/207657A2427E24C3901EC130AB754D96.png" alt="img"></p>
<p><strong>DFS算法（Final版）解决非连通图的问题</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited [MAX_ _VERTEX_ NUM]; <span class="comment">//访问标记数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;	<span class="comment">// 对图G进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G. vexnum; ++v)</span><br><span class="line">        visited[v]=FAL SE;	<span class="comment">//初始化已访问标记数据</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G. vexnum; ++v)	<span class="comment">//本代码中是从v=0开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[v])</span><br><span class="line">            <span class="built_in">DFS</span>(G,v) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;	<span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);	<span class="comment">//访问顶点V</span></span><br><span class="line">    vis ited [v]=TRUE;	<span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G, v) ;W&gt;=<span class="number">0</span>;w=<span class="built_in">NextNeighor</span>(G,v,W) )</span><br><span class="line">        <span class="keyword">if</span>(!visited [w])&#123;	<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G,w);</span><br><span class="line">        &#125; <span class="comment">//if </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230402113348230.png" alt="image-20230402113348230"></p>
<p>空间复杂度：来⾃函数调⽤栈，&#x3D;&#x3D;最坏情况&#x3D;&#x3D;，递归深度为&#x3D;&#x3D;O(|V|)&#x3D;&#x3D;</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230402113411268.png" alt="image-20230402113411268"></p>
<p>空间复杂度：最好情况，&#x3D;&#x3D;O(1)&#x3D;&#x3D;</p>
<hr>


<p>&#x3D;&#x3D;邻接矩阵&#x3D;&#x3D;存储的图： </p>
<p>访问 |V| 个顶点需要O(|V|)的时间 </p>
<p>查找每个顶点的邻接点都需要O(|V|)的时间，⽽总共有|V|个顶点 </p>
<p>&#x3D;&#x3D;时间复杂度&#x3D;&#x3D;&#x3D; O(|V|) + O(|V|^2^)   &#x3D; &#x3D;&#x3D;O(|V^2^|)&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;邻接表&#x3D;&#x3D;存储的图： </p>
<p>访问 |V| 个顶点需要O(|V|)的时间 </p>
<p>查找各个顶点的邻接点共需要O(|E|)的时间，（其实对于⽆向图来说，应该是O(2|E|) 的时间）</p>
<p>&#x3D;&#x3D;时间复杂度&#x3D; O(|V|) + O(|E|)&#x3D;&#x3D;</p>
<blockquote>
<p>时间复杂度&#x3D;访问各结点所需时间+探索各条边所需时间</p>
</blockquote>
<p>同⼀个图的&#x3D;&#x3D;邻接矩阵&#x3D;&#x3D;表示⽅式&#x3D;&#x3D;唯⼀&#x3D;&#x3D;，因此深度优先遍历序列&#x3D;&#x3D;唯⼀&#x3D;&#x3D; </p>
<p>同⼀个图&#x3D;&#x3D;邻接表&#x3D;&#x3D;表示⽅式&#x3D;&#x3D;不唯⼀&#x3D;&#x3D;，因此深度优先遍历序列&#x3D;&#x3D;不唯⼀&#x3D;&#x3D;</p>
<hr>


<p><strong>深度优先生成树和生成森林和广度类似</strong></p>
<p><strong>图的遍历与图的连通性</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230402113956487.png" alt="image-20230402113956487"></p>
<p>对&#x3D;&#x3D;⽆向图&#x3D;&#x3D;进⾏BFS&#x2F;DFS遍历 </p>
<p>调⽤BFS&#x2F;DFS函数的次数&#x3D;连通分量数 </p>
<p>对于连通图，只需调⽤1次 BFS&#x2F;DFS</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230402114034447.png" alt="image-20230402114034447"></p>
<p>对&#x3D;&#x3D;有向图&#x3D;&#x3D;进⾏BFS&#x2F;DFS遍历 </p>
<p>调⽤BFS&#x2F;DFS函数的次数要具体问题具体分析 </p>
<p>若起始顶点到其他各顶点都有路径，则只需调⽤1次 BFS&#x2F;DFS 函数</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230402114113524.png" alt="image-20230402114113524"></p>
<p>对于&#x3D;&#x3D;强连通图&#x3D;&#x3D;，从&#x3D;&#x3D;任⼀结点&#x3D;&#x3D;出发都只需&#x3D;&#x3D;调⽤1次 BFS&#x2F;DFS&#x3D;&#x3D;</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230402114232839.png" alt="image-20230402114232839"></p>
<h2 id="最⼩⽣成树问题"><a href="#最⼩⽣成树问题" class="headerlink" title="最⼩⽣成树问题"></a>最⼩⽣成树问题</h2><p>&#x3D;&#x3D;连通图&#x3D;&#x3D;的&#x3D;&#x3D;生成树&#x3D;&#x3D;是包含&#x3D;&#x3D;图中全部顶点&#x3D;&#x3D;的一个&#x3D;&#x3D;极小连通子图&#x3D;&#x3D;。 </p>
<p>若图中顶点数为n，则它的生成树含有 n-1 条边。对生成树而言，若砍去它的一条边，则会变成非连通 图，若加上一条边则会形成一个回路。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230403121314197.png" alt="image-20230403121314197"></p>
<p>最⼩⽣成树（最⼩代价树）</p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230403121358430.png" alt="image-20230403121358430" style="zoom:67%;">

<p>道路规划要求：所有地⽅都 连通，且成本尽可能的低</p>
<p>对于⼀个&#x3D;&#x3D;带权连通⽆向图&#x3D;&#x3D;G &#x3D; (V, E)，⽣成树不同，每棵树的权（即树中所有边上的权值 之和）也可能不同。设R为G的所有⽣成树的集合，若T为R中&#x3D;&#x3D;边的权值之和最⼩的⽣成树&#x3D;&#x3D;，则T称为G的最⼩⽣成树（Minimum-Spanning-Tree, MST）</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230403121558097.png" alt="image-20230403121558097"></p>
<ul>
<li><p>最⼩⽣成树可能有多个，但边的权值之和总是唯⼀且最⼩的 </p>
</li>
<li><p>最⼩⽣成树的边数 &#x3D; 顶点数 - 1。砍掉⼀条则不连通，增加⼀条边则会出现回路</p>
</li>
<li><p>如果⼀个连通图本身就是⼀棵树，则其最⼩⽣成树就是它本身 </p>
</li>
<li><p>只有连通图才有⽣成树，⾮连通图只有⽣成森林</p>
</li>
</ul>
<h3 id="Prim-算法（普⾥姆）"><a href="#Prim-算法（普⾥姆）" class="headerlink" title="Prim 算法（普⾥姆）"></a>Prim 算法（普⾥姆）</h3><p>Prim 算法（普⾥姆）： 从某⼀个顶点开始构建⽣成树； 每次将代价最⼩的新顶点纳⼊⽣成 树，直到所有顶点都纳⼊为⽌。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5B11676DAAF6CAA8F814E0F2EBD3FC3A.png" alt="img"></p>
<p>Prim 算法的实现思想</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230403124657191.png" alt="image-20230403124657191"></p>
<p>循环遍历所有个结点，找到lowCost最低的，且还没加⼊树的顶点</p>
<p>再次循环遍历，更新还没加⼊的各个顶点的lowCost值</p>
<p>从V0开始，总共需要 n-1 轮处理 </p>
<p>每⼀轮处理：循环遍历所有个结 点，找到lowCost最低的，且还没加⼊树的顶点。 </p>
<p>再次循环遍历，更新还没加⼊的 各个顶点的lowCost值——&#x3D;&#x3D;每⼀轮时间复 杂度O(2n)&#x3D;&#x3D;</p>
<p>总时间复杂度 &#x3D;&#x3D;O(n2)，即O(|V|2)&#x3D;&#x3D;</p>
<h3 id="Kruskal-算法（克鲁斯卡尔）"><a href="#Kruskal-算法（克鲁斯卡尔）" class="headerlink" title="Kruskal 算法（克鲁斯卡尔）"></a>Kruskal 算法（克鲁斯卡尔）</h3><p>Kruskal 算法（克鲁斯卡尔）： 每次选择⼀条权值最⼩的边，使这 条边的两头连通（原本已经连通的 就不选） 直到所有结点都连通</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230403124514749.png" alt="image-20230403124514749"></p>
<p>Kruskal 算法的实现思想</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230403125027972.png" alt="image-20230403125027972"></p>
<p>第1轮：检查第1条边的两个顶点是否 连通（是否属于同⼀个集合）</p>
<p>第2轮：检查第2条边的两个顶点是否 连通（是否属于同⼀个集合）</p>
<p>……</p>
<p> <img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230403125337178.png" alt="image-20230403125337178"></p>
<h2 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h2><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230404103931643.png" alt="image-20230404103931643"></p>
<h3 id="BFS—无权图"><a href="#BFS—无权图" class="headerlink" title="BFS—无权图"></a>BFS—无权图</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited [MAX_VERTEX_NUM]; <span class="comment">//访问标记数组 (初始都为false)</span></span><br><span class="line"><span class="type">int</span> d[],path[]; <span class="comment">//辅助数组</span></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123; <span class="comment">//从顶点v出发， 广度优先遍历图G</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        d[i]=∞；</span><br><span class="line">        path[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d[v]=<span class="number">0</span>;</span><br><span class="line">    visited [v]=TRUE;	<span class="comment">//对v做已访问标记</span></span><br><span class="line">    <span class="built_in">Enqueue</span>(Q,v);	<span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">isEmpty</span>(Q))&#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q,v);	<span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w=<span class="built_in">FirstNeighbor</span>(G, v) ;W&gt;=<span class="number">0</span> ;w=<span class="built_in">NextNeighbor</span>(G,v,W))</span><br><span class="line">            <span class="comment">//检测v所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(!visited [w])&#123; 	<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                d[w]=d[u]+<span class="number">1</span>;	<span class="comment">//路径长度加1</span></span><br><span class="line">                path[w]=v		<span class="comment">//最短路径应从v到w</span></span><br><span class="line">                visited [w]=TRUE;	<span class="comment">//对w做已访问标记</span></span><br><span class="line">                <span class="built_in">EnQueue</span>(Q,w); 	<span class="comment">//顶点w入队列</span></span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230404111624978.png" alt="image-20230404111624978"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230404111703664.png" alt="image-20230404111703664"></p>
<h3 id="Dĳkstra算法-——通用"><a href="#Dĳkstra算法-——通用" class="headerlink" title="Dĳkstra算法 ——通用"></a>Dĳkstra算法 ——通用</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230404122205809.png" alt="image-20230404122205809"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230404122215344.png" alt="image-20230404122215344"></p>
<p>初始：从V0开始，初始化三个数组信息如下</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230404122246083.png" alt="image-20230404122246083"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/A66EBDE3DEB088C1B80E0487C0787518.png" alt="img"></p>
<blockquote>
<p>每轮循环：</p>
<ol>
<li>循环遍历所有结点，找到还没确定最短路径，且dist 最⼩的顶点Vi，令final[i]&#x3D;ture。</li>
<li>检查所有邻接⾃ Vi 的顶点，若其 final 值为false， 则更新 dist 和 path 信息</li>
</ol>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230404130211798.png" alt="image-20230404130211798"></p>
<p>Dijkstra算法的时间复杂度</p>
<p>初始:</p>
<p>若从Vo开始，令<code>final[0]=ture</code>; <code>dist[0]=0</code>; <code>path[0]=-1</code>。其余顶点<code>final[k]=false</code>; <code>dist[k]=arcs[0][k]</code>;<code> path[k]= (arcs[0][k]==∞)?-1 :0</code><br>n-1轮处理:循环遍历所有顶点，找到还没确定最短路径，且dist最小的顶点V，令<code>final[i]=ture</code>。 并检查所有邻接自V;的顶点，对于邻接自Vi的顶点Vj，若<code>final[j]==false</code>且<code>dist[i]+arcs[i][j]&lt;dist[j]</code>，则令<code>dist[j]=dist[i]+arcs[i][j]</code>; <code>path[j]=i</code>。(注: arcs[][]表示Vi 到Vj的弧的权值)</p>
<blockquote>
<p>时间复杂度: &#x3D;&#x3D;O(n^2^)即O(|V|^2^)&#x3D;&#x3D;</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230404130859425.png" alt="image-20230404130859425"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230404130925609.png" alt="image-20230404130925609"></p>
<h3 id="Floyd算法——通用"><a href="#Floyd算法——通用" class="headerlink" title="Floyd算法——通用"></a>Floyd算法——通用</h3><p>Floyd算法：求出每⼀对顶点之间的最短路径 使⽤动态规划思想，将问题的求解分为多个阶段 对于n个顶点的图G，求任意⼀对顶点 Vi —&gt; Vj 之间的最短路径可分为如下⼏个阶段： </p>
<ol>
<li><p>0：初始：不允许在其他顶点中转，最短路径是？ </p>
</li>
<li><p>1：若允许在 V0 中转，最短路径是？ </p>
</li>
<li><p>2：若允许在 V0、V1 中转，最短路径是？ </p>
</li>
<li><p>3：若允许在 V0、V1、V2 中转，最短路径是？</p>
<p>…  </p>
<p>n-1：若允许在 V0、V1、V2 …… Vn-1 中转，最短路径是？</p>
</li>
</ol>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/F1CDE24366E25881E85375A6E824C961.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;	<span class="comment">//考虑以Vk作为中转点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123; <span class="comment">//遍历整个矩阵， i为行号，j为列号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i][j]&gt;A[i][k]+A[k][j])&#123; <span class="comment">//以 Vk为中转点的路径更短</span></span><br><span class="line">                A[i][j]=A[i][k]+A[k][j];            <span class="comment">//更新最短路径长度</span></span><br><span class="line">                path[i][j]=k;            <span class="comment">//中转点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度为&#x3D;&#x3D;O(|V|^3^)&#x3D;&#x3D;，空间复杂度为&#x3D;&#x3D;O(|V|^2^)&#x3D;&#x3D;</p>
<p><strong>Floyd算法可以⽤于负权值带权图</strong></p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230405201015004.png" alt="image-20230405201015004"></p>
<p>Floyd 算法不能解决带有“负权回路”的图（有负权值的边组成回路），这种图有可能没有最短路径</p>
<table>
<thead>
<tr>
<th></th>
<th>BFS 算法</th>
<th>Dĳkstra 算法</th>
<th>Floyd 算法</th>
</tr>
</thead>
<tbody><tr>
<td>⽆权图</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>带权图</td>
<td>❌</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td>带负权值的图</td>
<td>❌</td>
<td>❌</td>
<td>✔</td>
</tr>
<tr>
<td>带负权回路的图</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(|V|^2^)或O(|E|+|V|)</td>
<td>O(|V|^2^)</td>
<td>O(|V|^3^)</td>
</tr>
<tr>
<td>通常⽤于</td>
<td>求⽆权图的单源最短路径</td>
<td>求带权图的单源最短路径</td>
<td>求带权图中各顶点 间的最短路径</td>
</tr>
</tbody></table>
<blockquote>
<p>注：也可⽤ Dijkstra 算法求所有顶点间的最短路径，重复 |V| 次即可，总的时间复杂度也是O(|V|^3^)</p>
</blockquote>
<h2 id="有向无环图（DAG）"><a href="#有向无环图（DAG）" class="headerlink" title="有向无环图（DAG）"></a>有向无环图（DAG）</h2><h3 id="有向⽆环图-描述表达式"><a href="#有向⽆环图-描述表达式" class="headerlink" title="有向⽆环图  描述表达式"></a>有向⽆环图  描述表达式</h3><p>有向⽆环图：若⼀个&#x3D;&#x3D;有向图&#x3D;&#x3D;中&#x3D;&#x3D;不存在环&#x3D;&#x3D;，则称为有向⽆环图，简称DAG图（Directed Acyclic Graph）</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407213506402.png" alt="image-20230407213506402"></p>
<p>对于以下树结构，将其转化为DAG描述的图为</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407213542973.png" alt="image-20230407213542973"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407213642987.png" alt="image-20230407213642987"></p>
<blockquote>
<p>顶点中不可能出现重复的&#x3D;&#x3D;操作数&#x3D;&#x3D;</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407213820957.png" alt="image-20230407213820957"></p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407213854973.png" alt="image-20230407213854973" style="zoom: 80%;">

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>&#x3D;&#x3D;AOV⽹&#x3D;&#x3D;(Activity On Vertex NetWork，⽤顶点表示活动的⽹)： </p>
<p>&#x3D;&#x3D;⽤DAG图（有向⽆环图）&#x3D;&#x3D;表示⼀个⼯程。顶点表示活动，有向边 &lt;V<del>i</del> , V<del>j</del>&gt; 表示活动 V<del>i</del> 必须先于活动 V<del>j</del> 进⾏</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407214142335.png" alt="image-20230407214142335"></p>
<p>拓扑排序：在图论中，由⼀个有向⽆环图 的顶点组成的序列，当且仅当满⾜下列条件时，称为该图的⼀个拓扑排序： </p>
<p>① 每个顶点出现且只出现⼀次。 </p>
<p>② 若顶点A在序列中排在顶点B的前⾯，则 在图中不存在从顶点B到顶点A的路径。 </p>
<p>或定义为：拓扑排序是对有向⽆环图的顶 点的⼀种排序，它使得若存在⼀条从顶点A 到顶点B的路径，则在排序中顶点B出现在 顶点A的后⾯。<strong>每个AOV⽹都有⼀个或多个 拓扑排序序列。</strong></p>
<h4 id="拓扑排序的实现："><a href="#拓扑排序的实现：" class="headerlink" title="**拓扑排序的实现： **"></a>**拓扑排序的实现： **</h4><p>**① 从AOV⽹中选择⼀个没有前驱（&#x3D;&#x3D;⼊度为0&#x3D;&#x3D;）的顶点并输出。 **</p>
<p>**② 从⽹中删除该顶点和所有以它为起点的有向边。 **</p>
<p><strong>③ 重复①和②直到当前的&#x3D;&#x3D;AOV⽹为空&#x3D;&#x3D;或&#x3D;&#x3D;当前⽹中不存在⽆前驱的顶点为⽌&#x3D;&#x3D;。</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407214447977.png" alt="image-20230407214447977"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100</span></span><br><span class="line"><span class="comment">//图中顶点数目的最大值</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span> &#123;	<span class="comment">//边表结点</span></span><br><span class="line">    <span class="type">int</span> adjvex; <span class="comment">//该弧所指向的顶点的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> * nextarc;	<span class="comment">//指向下-条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info; //网的边权值</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span>&#123; <span class="comment">//顶点表结点</span></span><br><span class="line">    VertexType data;	<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;	<span class="comment">//指向第一条依附该顶点的弧的指针</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    AdjList vertices;	<span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum; <span class="comment">//图的顶点数和弧数</span></span><br><span class="line">&#125; Graph;	<span class="comment">//Graph是以邻接表存储的图类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">TopologicalSort</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);	<span class="comment">//初始化栈，存储入度为0的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++ ) </span><br><span class="line">        <span class="keyword">if</span>( indegree[i]==<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">Push</span>(S,i);	<span class="comment">//将所有入度为0的顶点进栈</span></span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;	<span class="comment">//计数，记录当前已经输出的顶点数</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(S))&#123;	<span class="comment">//栈不空，则存在入度为0的顶点</span></span><br><span class="line">        <span class="built_in">Pop</span>(S,i);	<span class="comment">//栈顶元素出栈  (每个顶点都需要处理⼀次)</span></span><br><span class="line">        print[count++]=i;	<span class="comment">//输出顶点i</span></span><br><span class="line">        <span class="keyword">for</span>(p=G.vertices[i].firstarc;p;p=p-&gt;nextarc)&#123;</span><br><span class="line">            <span class="comment">//将所有i指向的顶点的入度减1，并且将入度减为0的顶点压入栈S</span></span><br><span class="line">            v=p-&gt;adjvex; <span class="comment">//(每条边都需要处理⼀次)</span></span><br><span class="line">            <span class="keyword">if</span>(!(--indegree[v]))</span><br><span class="line">                <span class="built_in">Push</span>(S,v); <span class="comment">//入度为0， 则入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//while</span></span><br><span class="line">    <span class="keyword">if</span> ( count&lt;G . vexnum)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//排序失败，有向图中有回路</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span>	<span class="literal">true</span>;	<span class="comment">//拓扑排序成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407215119819.png" alt="image-20230407215119819" style="zoom:80%;">

<blockquote>
<p>时间复杂度：&#x3D;&#x3D;O(|V|+|E|)&#x3D;&#x3D;</p>
<p>若采⽤邻接矩阵，则需O(|V|2)</p>
</blockquote>
<p>逆拓扑排序</p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407215810737.png" alt="image-20230407215810737" style="zoom:80%;">

<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407215833235.png" alt="image-20230407215833235" style="zoom:80%;">

<blockquote>
<p>若模仿上面的拓扑排序的代码，由于邻接表时间复杂度开销过大，逆拓扑排序需要考虑使用存储为<em>邻接矩阵</em>，而非邻接表，当然也可以用<em>逆邻接表</em></p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407220106751.png" alt="image-20230407220106751"></p>
<h4 id="逆拓扑排序的实现（DFS算法）"><a href="#逆拓扑排序的实现（DFS算法）" class="headerlink" title="逆拓扑排序的实现（DFS算法）"></a>逆拓扑排序的实现（DFS算法）</h4><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407220513770.png" alt="image-20230407220513770" style="zoom:67%;">

<p>逆拓扑排序序列：4 3 1 0 2 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;	<span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span> ;V&lt;G. vexnum; ++v)</span><br><span class="line">        visited [v]=FALSE;	<span class="comment">//初始化已访问标记数据</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>; v&lt;G. vexnum;++v)	<span class="comment">//本代码中是从v=0开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>( !visited[v])</span><br><span class="line">            <span class="built_in">DFS</span>(G,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="type">int</span> v)</span></span>&#123;	<span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);	<span class="comment">//访问顶点v</span></span><br><span class="line">    visited [v]=TRUE;	<span class="comment">//设已访问标记</span></span><br><span class="line">    <span class="keyword">for</span> (w=FirstNe <span class="built_in">ighbor</span>(G, v) ;W&gt;=<span class="number">0</span> ;w=<span class="built_in">NextNeighor</span>(G,V,W))</span><br><span class="line">        <span class="keyword">if</span>(!visited[w])&#123; 	<span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G,W);</span><br><span class="line">        &#125; <span class="comment">//if、</span></span><br><span class="line">    <span class="built_in">print</span>(v); <span class="comment">//DFS实现逆拓扑排序：在顶点退栈前输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思考：如果存在回路，则不存在逆 拓扑排序序列，如何判断回路?</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407220632207.png" alt="image-20230407220632207"></p>
<h3 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h3><p>AOE⽹</p>
<p>在带权有向图中，以&#x3D;&#x3D;顶点表示事件&#x3D;&#x3D;，以&#x3D;&#x3D;有向边表示活动&#x3D;&#x3D;，&#x3D;&#x3D;以边上的权值表示完成该活动的开销&#x3D;&#x3D;（如完成活动所需的时间），称之为⽤边表示活动的⽹络，简称&#x3D;&#x3D;AOE⽹&#x3D;&#x3D; (Activity On Edge NetWork)</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407223047011.png" alt="image-20230407223047011"></p>
<p>AOE⽹具有以下两个性质： 、</p>
<p>① 只有在某顶点所代表的事件发⽣后，从该顶点出发的各有向边所代表的活动才能开始； </p>
<p>② 只有在进⼊某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发⽣。 另外，有些活动是可以并⾏进⾏的</p>
<p>在AOE⽹中<em>仅有⼀个⼊度为0的顶点</em>，称为&#x3D;&#x3D;开始顶点（源点&#x3D;&#x3D;），它表示整个⼯程的开始； 也<em>仅有⼀个出度为0的顶点</em>，称为&#x3D;&#x3D;结束顶点（汇点）&#x3D;&#x3D;，它表示整个⼯程的结束。</p>
<p>从源点到汇点的有向路径可能有多条，所有路径中，<em>具有最⼤路径⻓度的路径</em> 称为 <em>关键路径</em>，⽽把<em>关键路径上的活动</em>称为<em>关键活动</em></p>
<p>完成整个⼯程的最短时间就是关键路径的⻓度，若关键活动不能按时完成，则整个⼯程的完成时间就会延⻓</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407223359503.png" alt="image-20230407223359503"></p>
<p>*事件 v<del>k</del> 的最早发⽣时间ve(k)*——决定了所有从vk开始的活动能够开⼯的最早时间</p>
<p>*活动 a<del>i</del> 的最早开始时间e(i)*——指该活动弧的起点所表⽰的事件的最早发⽣时间</p>
<p>*事件v<del>k</del>的最迟发⽣时间vl(k)*——它是指在不推迟整个⼯程完成的前提下，该事件最迟必须发⽣的时间。</p>
<p>*活动a<del>i</del>的最迟开始时间l(i)*——它是指该活动弧的终点所表示事件的最迟发⽣时间与该活动所需时间之差。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407223710577.png" alt="image-20230407223710577"></p>
<p>求关键路径的步骤</p>
<p>① 求所有事件的最早发⽣时间 ve( )  </p>
<p>② 求所有事件的最迟发⽣时间 vl( )  </p>
<p>③ 求所有活动的最早发⽣时间 e( )  </p>
<p>④ 求所有活动的最迟发⽣时间 l( )  </p>
<p>⑤ 求所有活动的时间余量 d( ) ——d(i)&#x3D;0的活动就是关键活动, 由 关键活动可得关键路径</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407223933443.png" alt="image-20230407223933443"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407223959728.png" alt="image-20230407223959728"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407224032834.png" alt="image-20230407224032834"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407224047486.png" alt="image-20230407224047486"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407224118334.png" alt="image-20230407224118334"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407224133931.png" alt="image-20230407224133931"></p>
<p>关键活动、关键路径的特性：</p>
<ol>
<li>若关键活动耗时增加，则整个⼯程的⼯期将增⻓ </li>
<li>缩短关键活动的时间，可以缩短整个⼯程的⼯期 </li>
<li>当缩短到⼀定程度时，关键活动可能会变成⾮关键活动</li>
<li>可能有多条关键路径，只提⾼⼀条关键路径上的关键活动速度并不能缩短整个⼯程的⼯ 期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短⼯期的⽬的。</li>
</ol>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230407224257897.png" alt="image-20230407224257897"></p>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h2><p>基本概念：</p>
<p>&#x3D;&#x3D;查找&#x3D;&#x3D;——在 数据集合中寻找满足某种条件的数据元素的过程称为查找<br>&#x3D;&#x3D;查找表(查找结构)&#x3D;&#x3D;——用 于查找的数据集合称为查找表，它由同一类型的数据元素(或记录)组成<br>&#x3D;&#x3D;关键字&#x3D;&#x3D;一一数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408092851934.png" alt="image-20230408092851934"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408093107809.png" alt="image-20230408093107809"></p>
<p>对查找表的常⻅操作：</p>
<p>①查找符合条件的数据元素  </p>
<p>②插⼊、删除某个数据元素</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408093131308.png" alt="image-20230408093131308"></p>
<p>查找算法的评价指标：<br>查找⻓度——在查找运算中，需要对⽐关键字的次数称为查找⻓度  </p>
<p>平均查找⻓度（ASL, Average Search Length）—— 所有查找过程中进⾏关键字的⽐较次数的平均值</p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408093249715.png" alt="image-20230408093249715" style="zoom: 80%;">

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408093409804.png" alt="image-20230408093409804"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408093438380.png" alt="image-20230408093438380"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230408093454317.png" alt="image-20230408093454317"></p>
<h2 id="常见查找"><a href="#常见查找" class="headerlink" title="常见查找"></a>常见查找</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>顺序查找的算法思想：顺序查找，⼜叫“线性查找”，通常⽤于线性表。  算法思想：从头到 jio 挨个找（或者反过来也OK）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;	<span class="comment">//查找表的数据结构(顺序表)</span></span><br><span class="line">    ElemType *elem;	<span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;	<span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;	</span><br><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ST.TableLen &amp;&amp; ST.elem[i] !=key; ++i);</span><br><span class="line">    <span class="comment">//查找成功，则返回元素下标;查找失败，则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> i== =ST.TableLen? <span class="number">-1</span> : i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺序查找的实现（哨兵）：从尾到头（在头部设置“哨兵”）</p>
<p>数据从下标1开始存</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;	<span class="comment">//查找表的数据结构(顺序表)</span></span><br><span class="line">    ElemType *elem;	<span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;	<span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;	</span><br><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable ST,ElemType key)</span></span>&#123;</span><br><span class="line">    ST.elem[<span class="number">0</span>]=key;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=ST.TableLen;ST.elem[i] !=key;--i); <span class="comment">//从后往前找</span></span><br><span class="line">    <span class="keyword">return</span> i;	<span class="comment">//查找成功，则返回元素下标;查找失败，则返回04</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>优点：⽆需判断是否越 界，效率更⾼ ；0号位置存 “哨兵”</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230413162523696.png" alt="image-20230413162523696"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230413162543412.png" alt="image-20230413162543412"></p>
<blockquote>
<p>⼀个成功结点的查找⻓度 &#x3D; ⾃身所在层数  </p>
<p>⼀个失败结点的查找⻓度 &#x3D; 其⽗节点所在层数  </p>
<p>默认情况下，各种失败情况或成功情况都等概率发⽣</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230413162616492.png" alt="image-20230413162616492"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230413162628251.png" alt="image-20230413162628251"></p>
<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>折半查找，⼜称“⼆分查找”，仅适⽤于&#x3D;&#x3D;有序的顺序表&#x3D;&#x3D;。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230415103419623.png" alt="image-20230415103419623"></p>
<p>mid为中间指针，其值为low和heigh的指针除2向下取整（也可向上取整，在后面提到）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;	<span class="comment">//查找表的数据结构(顺序表)</span></span><br><span class="line">    ElemType *elem;	<span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="type">int</span> TableLen;	<span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Binary_Search</span><span class="params">(SSTable L, ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>, high=L. TableLen<span class="number">-1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span>( low&lt;=high)&#123;</span><br><span class="line">        mid=( low+high)/<span class="number">2</span>;	<span class="comment">//取中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid]==key) </span><br><span class="line">            <span class="keyword">return</span> mid;	<span class="comment">//查找成功则返回所在位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem [mid]&gt;key)</span><br><span class="line">            high=mid<span class="number">-1</span>;	<span class="comment">//从前半部分继续查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low=mid+<span class="number">1</span>;<span class="comment">//从后半部分继续查找</span></span><br><span class="line">    &#125;<span class="keyword">return</span>- <span class="number">1</span> ;<span class="comment">//查找失败，返回-1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>折半查找判定树的构造</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230415104605576.png" alt="image-20230415104605576"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230415104632147.png" alt="image-20230415104632147"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230415104658085.png" alt="image-20230415104658085"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230415104722226.png" alt="image-20230415104722226"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230415104752075.png" alt="image-20230415104752075"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230415104835095.png" alt="image-20230415104835095"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230415104919934.png" alt="image-20230415104919934"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230415104936343.png" alt="image-20230415104936343"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230415105326150.png" alt="image-20230415105326150"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230415105340761.png" alt="image-20230415105340761"></p>
<h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230422124337251.png" alt="image-20230422124337251"></p>
<blockquote>
<p>分块查找，⼜称索引顺序查找，算法过程如下：  </p>
<p>①在索引表中确定待查记录所属的分块（可顺序、可折半）  </p>
<p>②在块内顺序查找</p>
<p>若超出分块范围，则查找失败</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230422124752670.png" alt="image-20230422124752670"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230422124826306.png" alt="image-20230422124826306"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230422124849662.png" alt="image-20230422124849662"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230422124905379.png" alt="image-20230422124905379"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230422124952337.png" alt="image-20230422124952337"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230422125005105.png" alt="image-20230422125005105"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230422125051514.png" alt="image-20230422125051514"></p>
<h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><h3 id="散列表（Hash-Table）"><a href="#散列表（Hash-Table）" class="headerlink" title="散列表（Hash Table）"></a>散列表（Hash Table）</h3><p>&#x3D;&#x3D;散列表&#x3D;&#x3D;（Hash Table），⼜称&#x3D;&#x3D;哈希表&#x3D;&#x3D;。是⼀种数据结构，特点是：数据元素的&#x3D;&#x3D;关键字&#x3D;&#x3D;与其 存储地址&#x3D;&#x3D;直接相关&#x3D;&#x3D;</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230517221739387.png" alt="image-20230517221739387"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230517221753998.png" alt="image-20230517221753998"></p>
<blockquote>
<p>⽤&#x3D;&#x3D;拉链法&#x3D;&#x3D;（⼜称链接法、链地址法）处理“冲突”：&#x3D;&#x3D;把所有“同义词”存储在⼀个链表中&#x3D;&#x3D;</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230517221948824.png" alt="image-20230517221948824"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230517221958887.png" alt="image-20230517221958887"></p>
<blockquote>
<p>有的教材也会把“空指针” 的判定算作⼀次⽐较</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230517222214610.png" alt="image-20230517222214610"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230517222313881.png" alt="image-20230517222313881"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230517222323058.png" alt="image-20230517222323058"></p>
<h3 id="常见散列函数"><a href="#常见散列函数" class="headerlink" title="常见散列函数"></a>常见散列函数</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230517222404897.png" alt="image-20230517222404897"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230517222424933.png" alt="image-20230517222424933"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230517222432999.png" alt="image-20230517222432999"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230517222440613.png" alt="image-20230517222440613"></p>
<h3 id="散列查找-1"><a href="#散列查找-1" class="headerlink" title="散列查找"></a>散列查找</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520163910586.png" alt="image-20230520163910586"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520163924067.png" alt="image-20230520163924067"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520163933418.png" alt="image-20230520163933418"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520163946605.png" alt="image-20230520163946605"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164110238.png" alt="image-20230520164110238"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164205790.png" alt="image-20230520164205790"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164233917.png" alt="image-20230520164233917"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164301568.png" alt="image-20230520164301568"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164323631.png" alt="image-20230520164323631"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164336103.png" alt="image-20230520164336103"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164345092.png" alt="image-20230520164345092"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164413446.png" alt="image-20230520164413446"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164427439.png" alt="image-20230520164427439"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164449527.png" alt="image-20230520164449527"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164505165.png" alt="image-20230520164505165"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164517154.png" alt="image-20230520164517154"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164527833.png" alt="image-20230520164527833"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164545634.png" alt="image-20230520164545634"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164553515.png" alt="image-20230520164553515"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164606732.png" alt="image-20230520164606732"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230520164613028.png" alt="image-20230520164613028"></p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h2><p>&#x3D;&#x3D;排序（Sort）&#x3D;&#x3D;，就是重新排列表中的元素，使表中的元素满⾜&#x3D;&#x3D;按关键字有序&#x3D;&#x3D;的过程。 </p>
<p> 输⼊：n个记录R1, R2,…, Rn，对应的关键字为k1, k2,…, kn。 输出：输⼊序列的⼀个重排R1ʹ, R2ʹ,…, Rnʹ，使得有k1ʹ≤k2ʹ≤…≤knʹ（也可递减）</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526215517752.png" alt="image-20230526215517752"></p>
<p><strong>排序算法的评价指标</strong></p>
<p>算法的&#x3D;&#x3D;稳定性&#x3D;&#x3D;。若待排序表中有两个元素Ri和Rj，其对应的关键字相同即keyi &#x3D; keyj，且在排序 前Ri在Rj的前⾯，若使⽤某⼀排序算法排序后，Ri仍然在Rj的前⾯，则称这个排序算法是稳定 的，否则称排序算法是不稳定的。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526215626505.png" alt="image-20230526215626505"></p>
<p><strong>排序算法的分类</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526215702339.png" alt="image-20230526215702339"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">⼀个神奇的学习⽹站</a></p>
</blockquote>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><p>算法思想：每次将⼀个待排序的记录按其关键字⼤⼩插⼊到前⾯已排好序的⼦序列中， 直到全部记录插⼊完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[] ,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">1</span>; i&lt;n; i++)	<span class="comment">//将各元素插入已排好序的序列中</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;	<span class="comment">//若A[i]关键字小于前驱</span></span><br><span class="line">            temp=A[i];	<span class="comment">//用temp暂存A[i]</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=O &amp;&amp; A[j]&gt;temp;--j)	<span class="comment">//检查所有前面已排好序的元素</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];	<span class="comment">//所有大于temp的元素都向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>]=temp;	<span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526221630469.png" alt="image-20230526221630469"></p>
<p><strong>算法实现（带哨兵）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序（带哨兵)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">2</span>; i&lt;=n; i++)	<span class="comment">//依次将A[2]~A[n]插入到前面已排序序列</span></span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123;	<span class="comment">//若A[i]关键码小于其前驱，将A[i]插入有序表</span></span><br><span class="line">            A[<span class="number">0</span>]=A[i];	<span class="comment">//复制为哨兵，A[0]不存放元素</span></span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;A[O]&lt;A[j];--j)	<span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">                A[j+<span class="number">1</span>]=A[j];	<span class="comment">//向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>]=A[<span class="number">0</span>];	<span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526221619146.png" alt="image-20230526221619146"></p>
<blockquote>
<p>空间复杂度：O(1) </p>
<p>时间复杂度：主要来⾃对⽐关键字、移动元素  若有 n 个元素，则需要 n-1 趟处理</p>
<p>最好情况：  共n-1趟处理，每⼀趟只需要对⽐关键字1次， 不⽤移动元素   <em>最好时间复杂度—— O(n)</em></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526221819831.png" alt="image-20230526221819831"></p>
<p>最坏情况：  第1趟：对⽐关键字2次，移动元素3次  第2趟：对⽐关键字3次，移动元素4次  …  第 i 趟：对⽐关键字 i+1次，移动元素 i+2 次  …</p>
<p><em>最坏时间复杂度——O(n^2^)</em></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526221855786.png" alt="image-20230526221855786"></p>
<p><em>总结：</em></p>
<p><em>空间复杂度：O(1)</em> </p>
<p><em>最好时间复杂度（全部有序）：O(n)</em>  </p>
<p><em>最坏时间复杂度（全部逆序）：O(n^2^)</em> </p>
<p><em>平均时间复杂度：O(n^2^)</em> </p>
<p><em>算法稳定性：稳定</em></p>
</blockquote>
<p><strong>优化——折半插⼊排序</strong></p>
<p>思路：先⽤折半查找找到应该插⼊的位置，再移动元素</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526222118830.png" alt="image-20230526222118830"></p>
<p>当 low&gt;high 时折半查找停⽌，应将 [low, i-1] 内的元素全部右移，并将 A[0] 复制到 low 所指位置</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526222147925.png" alt="image-20230526222147925"></p>
<p>当 &#x3D;&#x3D;A[mid]&#x3D;&#x3D;A[0]&#x3D;&#x3D; 时，为了保证算法的“<em>稳定性</em>”，&#x3D;&#x3D;应继续在 mid 所指位置右边寻找插⼊位置&#x3D;&#x3D;</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526222231048.png" alt="image-20230526222231048"></p>
<p>当 low&gt;high 时折半查找停⽌，应将 &#x3D;&#x3D;[low, i-1] （也可以写为 [high+1,i-1]）&#x3D;&#x3D; 内的元素全部右移，并将 A[0] 复制到 low 所指位置，当 A[mid]&#x3D;&#x3D;A[0] 时，为了保证算法的“稳定性”，应继续在 mid 所指位置右边寻找插⼊位置</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526223936478.png" alt="image-20230526223936478"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526223952318.png" alt="image-20230526223952318"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半插入排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[] ,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">2</span>; i&lt;=n; i++)&#123;	<span class="comment">//依次将A[2]~一A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>]=A[i];	<span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low=<span class="number">1</span>;high=i<span class="number">-1</span>;	<span class="comment">//设置折半查找的范围</span></span><br><span class="line">        <span class="keyword">while</span>( low&lt;=high)&#123;	<span class="comment">//折半查找(默认递增有序)</span></span><br><span class="line">            mid=( low+high)/<span class="number">2</span>;	<span class="comment">//取中间点</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid]&gt;A[<span class="number">0</span>] ) </span><br><span class="line">                high=mid<span class="number">-1</span>;	<span class="comment">//查找左半子表</span></span><br><span class="line">            <span class="keyword">else</span> low=mid+<span class="number">1</span>;	<span class="comment">//查找右半子表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( j=i<span class="number">-1</span>; j&gt;=high+<span class="number">1</span>;--j)</span><br><span class="line">            A[j+<span class="number">1</span>]=A[j];	<span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">        A[high+<span class="number">1</span>]=A[<span class="number">0</span>];	<span class="comment">//插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⽐起“直接插⼊排序”，⽐较关键字的次 数减少了，但是移动元素的次数没变， 整体来看&#x3D;&#x3D;时间复杂度依然是O(n^2^)&#x3D;&#x3D;</p>
</blockquote>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526224323882.png" alt="image-20230526224323882" style="zoom:80%;">

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526224339228.png" alt="image-20230526224339228"></p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526225945698.png" alt="image-20230526225945698"></p>
<p>希尔排序：先将待排序表分割成若⼲形如 L[i, i + d, i + 2d,…, i + kd] 的“特殊”⼦表，对各个⼦表 分别进⾏直接插⼊排序。&#x3D;&#x3D;缩⼩增量d&#x3D;&#x3D;，重复上述过程，直到d&#x3D;1为⽌。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526230010480.png" alt="image-20230526230010480"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526230020434.png" alt="image-20230526230020434"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526230057192.png" alt="image-20230526230057192"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526230035070.png" alt="image-20230526230035070"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526230104347.png" alt="image-20230526230104347"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526230117514.png" alt="image-20230526230117514"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526230124665.png" alt="image-20230526230124665"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526230141522.png" alt="image-20230526230141522"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Shellsort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> d,i,j;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已到</span></span><br><span class="line">    <span class="keyword">for</span>(d= n/<span class="number">2</span>; d&gt;=<span class="number">1</span>; d=d/<span class="number">2</span>)	<span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span>( i=d+<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;A[i-d] )&#123;	<span class="comment">//需将A[i]插入有序增量子表</span></span><br><span class="line">                A[<span class="number">0</span>]=A[i];	<span class="comment">//暂存在A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j= i-d; j&gt;<span class="number">0</span> &amp;&amp; A[O]&lt;A[j]; j-=d)</span><br><span class="line">                    A[j+d]=A[j];	<span class="comment">//记录后移，查找插入的位置</span></span><br><span class="line">                A[j+d]=A[<span class="number">0</span>];	<span class="comment">//插入</span></span><br><span class="line">            &#125;<span class="comment">//if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>算法性能分析</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526230413255.png" alt="image-20230526230413255"></p>
<blockquote>
<p>&#x3D;&#x3D;空间复杂度：O(1)&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;时间复杂度：&#x3D;&#x3D;和增量序列 d1, d2, d3… 的选择有关，⽬前&#x3D;&#x3D;⽆法⽤数学⼿段证明确切的时间复杂度&#x3D;&#x3D;  </p>
<p>最坏时间复杂度为 O(n^2^)，当n在某个范围内时，可达O(n^1.3^)</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526230607269.png" alt="image-20230526230607269"></p>
<blockquote>
<p><em>稳定性：不稳定！</em></p>
<p><em>适⽤性：仅适⽤于顺序表，不适⽤于链表</em></p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230526230638416.png" alt="image-20230526230638416"></p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>从后往前（或从前往后）两两⽐较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换它们，直到序 列⽐较完。称这样过程为“⼀趟”冒泡排序。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230527210954772.png" alt="image-20230527210954772"></p>
<p>从后往前（或从前往后）两两⽐较相邻元素的值，若为逆序（即A[i-1]&gt;A[i]），则交换它们，直到序 列⽐较完。称这样过程为“⼀趟”冒泡排序。总共需进⾏ n-1 趟冒泡。</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230527211115192.png" alt="image-20230527211115192"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a= b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(<span class="type">int</span> A[] ,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;	<span class="comment">//表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=n<span class="number">-1</span>; j&gt;i;j--)	<span class="comment">//一趟冒泡过程</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>]&gt;A[j])&#123;	<span class="comment">//若为逆序</span></span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]);	<span class="comment">//交换</span></span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)</span><br><span class="line">            <span class="keyword">return</span>;	<span class="comment">//本趟遍历后没有发生交换，说明表已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有A[ j -1]&gt;A[ j ]时才交 换，因此算法是稳定的</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230527211522497.png" alt="image-20230527211522497"></p>
<p><strong>算法性能分析</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230527212103165.png" alt="image-20230527212103165"></p>
<blockquote>
<p>冒泡排序同样适⽤于链表</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230527212155650.png" alt="image-20230527212155650"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230527212316354.png" alt="image-20230527212316354"></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>算法思想：在待排序表L[1…n]中任取⼀个元素pivot作为枢轴（或基准，通常取⾸元素），通过⼀趟排序将待排序表划 分为独⽴的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素⼩于pivot，L[k+1…n]中的所有元素⼤于等于 pivot，则pivot放在了其最终位置L(k)上，这个过程称为⼀次“划分”。然后分别递归地对两个⼦表重复上述过程，直⾄ 每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。</p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531204839111.png" alt="image-20230531204839111" style="zoom: 80%;">

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531204905992.png" alt="image-20230531204905992"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531204917413.png" alt="image-20230531204917413"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531204932747.png" alt="image-20230531204932747"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531204946611.png" alt="image-20230531204946611"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531204953689.png" alt="image-20230531204953689"></p>
<blockquote>
<p>总结：取出一个元素（这个元素一般去low所指的，即第一个元素）做为枢轴，用一个变量存放，heigh向左移动直到找到比枢轴更小的元素，将这个元素放入low的位置，low开始向右移动直到找到一个比枢轴大的元素，放到heigh所指位置，heigh开始移动……循环直到low和heigh指向同一个位置，最后将枢轴元素放到这个位置</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> A[ ] ,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;<span class="comment">//递归跳出的条件</span></span><br><span class="line">        <span class="type">int</span> pivotpos=Partition(A,low, high); <span class="comment">//划分</span></span><br><span class="line">        QuickSort(A, low, pivotpos<span class="number">-1</span>);<span class="comment">//划分左子表</span></span><br><span class="line">        QuickSort(A, pivotpos+<span class="number">1</span>,high);<span class="comment">//划分右子表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用第一个元素将待排序序列划分成左右两个部分</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">( <span class="type">int</span> A[] ,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot=A[low];	<span class="comment">//第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>( low&lt;high)&#123;	<span class="comment">//用low、high搜索枢轴的最终位置</span></span><br><span class="line">        <span class="keyword">while</span>( low&lt;high&amp;&amp;A [high]&gt;=pivot) --high;</span><br><span class="line">        A[low]=A[high];	<span class="comment">//比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>( low&lt;high&amp;&amp;A [ low]&lt;=pivot) ++low;</span><br><span class="line">        A[high]=A[ low];	<span class="comment">//比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A [low]=pivot;	<span class="comment">//枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;		<span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531205906955.png" alt="image-20230531205906955"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531210145590.png" alt="image-20230531210145590"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531210156444.png" alt="image-20230531210156444"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531210209740.png" alt="image-20230531210209740"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531210224487.png" alt="image-20230531210224487"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531210258823.png" alt="image-20230531210258823"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531210314147.png" alt="image-20230531210314147"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531210326446.png" alt="image-20230531210326446"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230531210351570.png" alt="image-20230531210351570"></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><blockquote>
<p><em>每⼀趟在待排序元素中选取关键字最⼩的元素加⼊有序⼦序列</em></p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608193425485.png" alt="image-20230608193425485"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608193434830.png" alt="image-20230608193434830"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>;i++)&#123;	<span class="comment">//一共进行n-1趟</span></span><br><span class="line">        <span class="type">int</span> min=i;	<span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;n; j++)	<span class="comment">//在A[i..n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min] ) min=j;	<span class="comment">//更新最小元素位置</span></span><br><span class="line">        <span class="keyword">if</span>(min!=i) swap(A[i],A[min] );	<span class="comment">//封装的swap()函数共移动元素3次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line">vodi <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>&#123;</span><br><span class="line">	<span class="type">int</span> temp  = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608193733126.png" alt="image-20230608193733126"></p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608193749150.png" alt="image-20230608193749150" style="zoom:67%;">

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608193806911.png" alt="image-20230608193806911"></p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608193845829.png" alt="image-20230608193845829"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608193859942.png" alt="image-20230608193859942"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608193917429.png" alt="image-20230608193917429"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608193956601.png" alt="image-20230608193956601"></p>
<p>思路：把所有⾮终端结点都检查⼀遍，是否满 ⾜⼤根堆的要求，如果不满⾜，则进⾏调整</p>
<p>在顺序存储的完全⼆叉树中，⾮终端结点编号 i≤ $\lfloor n&#x2F;2 \rfloor$</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608194324635.png" alt="image-20230608194324635"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608194353918.png" alt="image-20230608194353918"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608194415979.png" alt="image-20230608194415979"></p>
<p><strong>建⽴⼤根堆（代码</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">( <span class="type">int</span> A[] ,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>; i&gt;<span class="number">0</span>; i--)<span class="comment">//从后往前调整所有非终端结点</span></span><br><span class="line">        HeadAdjust(A, i,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将以k 为根的子树调整为大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    A[<span class="number">0</span>]=A[k]; 	<span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*k ; i&lt;=len; i*=<span class="number">2</span>)&#123;	<span class="comment">//沿key较大的子结点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>( i&lt;len&amp;&amp;A[i]&lt;A[i+<span class="number">1</span>])</span><br><span class="line">            i++;	<span class="comment">//取key较大的子结点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>]&gt;=A[i])<span class="keyword">break</span>;	<span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A [k]=A[i];	<span class="comment">//将A[i]调整到双亲结点上</span></span><br><span class="line">            k=i;	<span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k]=A[<span class="number">0</span>];	<span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608195447218.png" alt="image-20230608195447218"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608195722172.png" alt="image-20230608195722172"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608195822559.png" alt="image-20230608195822559"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608195843314.png" alt="image-20230608195843314"></p>
<p><strong>基于⼤根堆进⾏排序（代码）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[ ],<span class="type">int</span> len)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[] ,<span class="type">int</span> k,<span class="type">int</span> len)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    BuildMaxHeap(A,len);	<span class="comment">//初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len; i&gt;<span class="number">1</span>;i--)&#123;	<span class="comment">// n-1趟的交换和建堆过程</span></span><br><span class="line">        swap(A[i],A[<span class="number">1</span>]); 	<span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);	<span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608200104821.png" alt="image-20230608200104821"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608200142947.png" alt="image-20230608200142947"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608200301077.png" alt="image-20230608200301077"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608200317463.png" alt="image-20230608200317463"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608200331611.png" alt="image-20230608200331611"></p>
<blockquote>
<p>结论：堆排序是不稳定的</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230608200419861.png" alt="image-20230608200419861"></p>
<h3 id="堆的插入和删除"><a href="#堆的插入和删除" class="headerlink" title="堆的插入和删除"></a>堆的插入和删除</h3><p>对于⼩根堆，新元素放到表尾，与⽗节点对⽐， 若新元素⽐⽗节点更⼩，则将⼆者互换。新元素 就这样⼀路“上升”，直到⽆法继续上升为⽌</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611135934885.png" alt="image-20230611135934885"></p>
<p>被删除的元素⽤堆底元素替代，然后让该 元素不断“下坠”，直到⽆法下坠为⽌</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611140033590.png" alt="image-20230611140033590"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611140040181.png" alt="image-20230611140040181"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611140109022.png" alt="image-20230611140109022"></p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><strong>归并：把两个或多个已经有序的序列合并成⼀个</strong></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611141843567.png" alt="image-20230611141843567"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611141857077.png" alt="image-20230611141857077"></p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611141921404.png" alt="image-20230611141921404" style="zoom: 67%;">

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611141945152.png" alt="image-20230611141945152"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611142002139.png" alt="image-20230611142002139"></p>
<p><strong>代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//辅助数组B</span></span><br><span class="line"><span class="comment">//A[low...mid]和A[mid+...high]各自有序，将两个部分归并</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k=low ; k&lt;=high; k++)</span><br><span class="line">        B[k]=A[k];	<span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">    <span class="keyword">for</span>( i=low,j=mid+<span class="number">1</span>,k=i; i&lt;=mid&amp;&amp;j&lt;=high; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i]&lt;=B[j])</span><br><span class="line">            A[k]=B[i++];   <span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k]=B[j++];</span><br><span class="line">    &#125;	<span class="comment">// for</span></span><br><span class="line">    <span class="keyword">while</span>( i&lt;=mid)  A[k++]=B[i++] ;</span><br><span class="line">    <span class="keyword">while</span>( j&lt;=high) A[k++]=B[j++] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[] ,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid=( low+high)/<span class="number">2</span>;	<span class="comment">//从中间划分</span></span><br><span class="line">        MergeSort(A,low,mid);	<span class="comment">//对左半部分归并排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high);<span class="comment">//对右半部分归并排序</span></span><br><span class="line">        Merge(A,low,mid,high);<span class="comment">//归并</span></span><br><span class="line">    &#125;	<span class="comment">//if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意递归调用</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611142617957.png" alt="image-20230611142617957"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611142632916.png" alt="image-20230611142632916"></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p> <img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611144554141.png" alt="image-20230611144554141"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611144625796.png" alt="image-20230611144625796"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611144641138.png" alt="image-20230611144641138"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611144659206.png" alt="image-20230611144659206"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611144712113.png" alt="image-20230611144712113"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611144725820.png" alt="image-20230611144725820"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611144739123.png" alt="image-20230611144739123"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611144806803.png" alt="image-20230611144806803"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611144820025.png" alt="image-20230611144820025"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611144831894.png" alt="image-20230611144831894"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611144917512.png" alt="image-20230611144917512"></p>
<blockquote>
<p><em>基数排序不是基于 “⽐较”的排序算法</em></p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611144954416.png" alt="image-20230611144954416"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611145008491.png" alt="image-20230611145008491"></p>
<blockquote>
<p><strong>基数排序是稳定的</strong></p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611145045050.png" alt="image-20230611145045050"></p>
<p>基数排序擅⻓解决的问题：  </p>
<ol>
<li>数据元素的关键字可以⽅便地拆分为 d 组，且 d 较⼩  </li>
<li>每组关键字的取值范围不⼤，即 r 较⼩  </li>
<li>数据元素个数 n 较⼤</li>
</ol>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611145139921.png" alt="image-20230611145139921"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611145151997.png" alt="image-20230611145151997"></p>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><h3 id="外部排序-1"><a href="#外部排序-1" class="headerlink" title="外部排序"></a>外部排序</h3><p>数据存放在外存中，需要拿到内存中进行数据操作</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611200253290.png" alt="image-20230611200253290"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611200414377.png" alt="image-20230611200414377"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611200449497.png" alt="image-20230611200449497"></p>
<p>构造初始“归并段”：”要求各个⼦序列有序，每次读⼊ 两个块的内容，进⾏内部排序后写回磁盘</p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611200619461.png" alt="image-20230611200619461"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611200634265.png" alt="image-20230611200634265"></p>
<blockquote>
<p>循环往复，16段变为8段，8段变为4段，4变为2段，最终形成一个有序序列</p>
<p><em>注意：当某一缓冲区数据清空后，要立即将其对应的归并段数据进行填充，然后才能继续进行归并操作</em></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611200957527.png" alt="image-20230611200957527"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611201012896.png" alt="image-20230611201012896"></p>
</blockquote>
<blockquote>
<p>输出缓冲区的数据会放到外存的一个新的位置，不会使用旧的存储位置，当旧的存储数据完成归并后会释放其内存地址</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611201640278.png" alt="image-20230611201640278"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611201700847.png" alt="image-20230611201700847"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611201727627.png" alt="image-20230611201727627"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611203232412.png" alt="image-20230611203232412"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611203250217.png" alt="image-20230611203250217"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611203338646.png" alt="image-20230611203338646"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611203347732.png" alt="image-20230611203347732"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611203413910.png" alt="image-20230611203413910"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611203427755.png" alt="image-20230611203427755"></p>
<h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611210718020.png" alt="image-20230611210718020"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611210923491.png" alt="image-20230611210923491"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611210940723.png" alt="image-20230611210940723"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611210949418.png" alt="image-20230611210949418"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611211002152.png" alt="image-20230611211002152"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611211135586.png" alt="image-20230611211135586"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611211153753.png" alt="image-20230611211153753"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611211219268.png" alt="image-20230611211219268"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611211234119.png" alt="image-20230611211234119"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611211242961.png" alt="image-20230611211242961"></p>
<h3 id="置换选择排序"><a href="#置换选择排序" class="headerlink" title="置换选择排序"></a>置换选择排序</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611212951662.png" alt="image-20230611212951662"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611213003483.png" alt="image-20230611213003483"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611213012460.png" alt="image-20230611213012460"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611213026681.png" alt="image-20230611213026681"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611213055852.png" alt="image-20230611213055852"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611213116541.png" alt="image-20230611213116541"></p>
<blockquote>
<p>首先取满内存工作区，将其中最小的元素放入归并段1，并记录此元素大小，内存工作区少了一个后就立即传入一个新的数据，再进行比较，重复上述操作。如果传入的新数据比记录的minmax小也不用管他，<em>最后直到工作区所有的数据都比minmax小，则说明第一个归并段的构造结束</em>。进行第二个归并段的构造，重复上述操作。</p>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611213703927.png" alt="image-20230611213703927"></p>
<p>知识回顾与重要考点</p>
<p>设初始待排⽂件为FI，初始归并段输出⽂件为FO，内存⼯作区为WA，FO和WA的初始状态为 空，WA可容纳w个记录。置换-选择算法的步骤如下： </p>
<ol>
<li>从FI输⼊w个记录到⼯作区WA。 </li>
<li>从WA中选出其中关键字取最⼩值的记录，记为MINIMAX记录。 </li>
<li>将MINIMAX记录输出到FO中去。  </li>
<li>若FI不空，则从FI输⼊下⼀个记录到WA中。 </li>
<li>从WA中所有关键字⽐MINIMAX记录的关键字⼤的记录中选出最⼩关键字记录，作为新的 MINIMAX记录。</li>
<li>重复③~⑤，直⾄在WA中选不出新的MINIMAX记录为⽌，由此得到⼀个初始归并段，输 出⼀个归并段的结束标志到FO中去。 </li>
<li>重复②~⑥，直⾄WA为空。由此得到全部初始归并段。</li>
</ol>
<h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611215335458.png" alt="image-20230611215335458"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611215344055.png" alt="image-20230611215344055"></p>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611215401761.png" alt="image-20230611215401761" style="zoom: 80%;">

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611215417562.png" alt="image-20230611215417562"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611215431638.png" alt="image-20230611215431638"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611215448132.png" alt="image-20230611215448132"></p>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611215501568.png" alt="image-20230611215501568"></p>
<blockquote>
<p>注意：对于k叉归并，<em>若初始归并段的数量⽆法构成严格的 k 叉归并树， 则需要补充⼏个⻓度为 0 的“虚段</em>”，再进⾏ k 叉哈夫曼树的构造。</p>
</blockquote>
<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611215510322.png" alt="image-20230611215510322" style="zoom:80%;">

<img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611215554310.png" alt="image-20230611215554310" style="zoom:80%;">

<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611215714214.png" alt="image-20230611215714214"></p>
<blockquote>
<p><strong>添加虚段的数量</strong></p>
<ol>
<li>若（初始归并段数量 -1）% （k-1）&#x3D; 0，说明刚好可以构成严格k叉树，此时不需要添加虚段 </li>
<li>若（初始归并段数量 -1）% （k-1）&#x3D; u ≠ 0，则需要补充 (k-1) - u 个虚段</li>
</ol>
</blockquote>
<p><img src="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230611215724801.png" alt="image-20230611215724801"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Oreges</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">http://example.com/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hexo</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/22/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%951/" title="图片测试1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">图片测试1</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/04/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Oreges</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/catmint163"><i class="fab fa-github"></i><span>关注我</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">oreges的个人博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">2.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.</span> <span class="toc-text">线性表的定义和基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">顺序表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.2.</span> <span class="toc-text">顺序表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">顺序表的插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">顺序表的查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">单链表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.2.</span> <span class="toc-text">单链表的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">单链表的插入和删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">单链表的查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">2.3.3.</span> <span class="toc-text">单链表的建立</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">尾插法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%8F%92%E6%B3%95"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">头插法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.4.</span> <span class="toc-text">双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.4.1.</span> <span class="toc-text">双链表的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">2.4.2.</span> <span class="toc-text">双链表的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.4.3.</span> <span class="toc-text">双链表的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">2.5.</span> <span class="toc-text">循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">循环单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">循环双链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8"><span class="toc-number">2.6.</span> <span class="toc-text">静态链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">2.6.1.</span> <span class="toc-text">静态链表定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.2.</span> <span class="toc-text">基本操作实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8vs%E9%93%BE%E8%A1%A8"><span class="toc-number">2.7.</span> <span class="toc-text">顺序表vs链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">3.1.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.1.</span> <span class="toc-text">栈的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">顺序栈的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-number">3.1.3.</span> <span class="toc-text">共享栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.4.</span> <span class="toc-text">链栈的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">3.2.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">队列的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.2.</span> <span class="toc-text">队列的顺序实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%B0%BE%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-%EF%BC%88%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%BA%94%E8%AF%A5%E6%8F%92%E5%85%A5%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">队尾指针指向队尾元素的后一个位置 （下一个应该插入的位置）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%B0%BE%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E9%98%9F%E5%B0%BE%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%8D%E7%BD%AE-%EF%BC%88%E5%BD%93%E5%89%8D%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">队尾指针指向队尾元素的位置 （当前插入元素的位置）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.3.</span> <span class="toc-text">队列的链式实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.2.4.</span> <span class="toc-text">双端队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%80%83%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">常见考点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="toc-number">3.3.1.</span> <span class="toc-text">栈的应用——括号匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC1"><span class="toc-number">3.3.2.</span> <span class="toc-text">栈的应用——表达式求值1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC2"><span class="toc-number">3.3.3.</span> <span class="toc-text">栈的应用——表达式求值2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E2%80%94%E2%80%94%E9%80%92%E5%BD%92"><span class="toc-number">3.3.4.</span> <span class="toc-text">栈的应用 ——递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.3.5.</span> <span class="toc-text">队列 的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5-%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">3.3.6.</span> <span class="toc-text">特殊矩阵 压缩存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">4.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">串的定义和基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">串的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">朴素模式匹配算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82next%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.1.</span> <span class="toc-text">求next数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">4.4.2.</span> <span class="toc-text">KMP算法的优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-number">5.1.1.</span> <span class="toc-text">定义和基本术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">树的性质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.2.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.2.1.</span> <span class="toc-text">二叉树的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.3.</span> <span class="toc-text">二叉树的存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88-x2F-%E4%B8%AD-x2F-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.1.</span> <span class="toc-text">先&#x2F;中&#x2F;后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%88%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%EF%BC%89"><span class="toc-number">5.3.2.</span> <span class="toc-text">二叉树的层次遍历（广度优先）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.3.3.</span> <span class="toc-text">由遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.3.4.</span> <span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="toc-number">5.3.5.</span> <span class="toc-text">二叉树的线索化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%89%8D%E9%A9%B1%E5%92%8C%E5%90%8E%E7%BB%A7"><span class="toc-number">5.3.6.</span> <span class="toc-text">在线索二叉树找前驱和后继</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="toc-number">5.3.6.1.</span> <span class="toc-text">中序线索二叉树找中序后继</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E4%B8%AD%E5%BA%8F%E5%89%8D%E9%A9%B1"><span class="toc-number">5.3.6.2.</span> <span class="toc-text">中序线索二叉树找中序前驱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%85%88%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="toc-number">5.3.6.3.</span> <span class="toc-text">先序线索二叉树找先序后继</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%85%88%E5%BA%8F%E5%89%8D%E9%A9%B1%EF%BC%88%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">5.3.6.4.</span> <span class="toc-text">先序线索二叉树找先序前驱（三叉链表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%90%8E%E5%BA%8F%E5%90%8E%E7%BB%A7%EF%BC%88%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">5.3.6.5.</span> <span class="toc-text">后序线索二叉树找后序后继（三叉链表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%90%8E%E5%BA%8F%E5%89%8D%E9%A9%B1"><span class="toc-number">5.3.6.6.</span> <span class="toc-text">后序线索二叉树找后序前驱</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-number">5.4.</span> <span class="toc-text">树和森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.1.</span> <span class="toc-text">树的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">5.4.2.</span> <span class="toc-text">树、森林的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">二叉排序树（BST）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.5.1.</span> <span class="toc-text">二叉排序树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-number">5.5.2.</span> <span class="toc-text">二叉排序树的查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">5.5.3.</span> <span class="toc-text">二叉排序树的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">5.5.4.</span> <span class="toc-text">二叉排序树的构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">5.5.5.</span> <span class="toc-text">二叉排序树的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">5.5.6.</span> <span class="toc-text">查找效率分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL"><span class="toc-number">5.6.</span> <span class="toc-text">平衡二叉树(AVL)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.6.1.</span> <span class="toc-text">平衡二叉树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">5.6.2.</span> <span class="toc-text">平衡二叉树的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-number">5.6.3.</span> <span class="toc-text">平衡二叉树的删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%AD%90%E6%A0%91"><span class="toc-number">5.6.4.</span> <span class="toc-text">调整最小不平衡子树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88RBT%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">红黑树（RBT）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.7.1.</span> <span class="toc-text">红黑树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">5.7.2.</span> <span class="toc-text">红黑树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">5.7.3.</span> <span class="toc-text">红黑树的插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%EF%BC%88%E5%9F%BA%E6%9C%AC%E4%B8%8D%E8%80%83%EF%BC%89"><span class="toc-number">5.7.4.</span> <span class="toc-text">红黑树的删除（基本不考）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-number">5.8.</span> <span class="toc-text">B树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.8.1.</span> <span class="toc-text">B树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span class="toc-number">5.8.2.</span> <span class="toc-text">B树的插入删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">5.8.3.</span> <span class="toc-text">B+树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">5.9.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.9.1.</span> <span class="toc-text">哈夫曼树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">5.9.2.</span> <span class="toc-text">哈夫曼树的构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">5.9.3.</span> <span class="toc-text">哈夫曼编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">5.10.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%9F%BA%E7%A1%80"><span class="toc-number">5.10.1.</span> <span class="toc-text">并查集基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">5.10.2.</span> <span class="toc-text">并查集的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%96"><span class="toc-number">5.10.3.</span> <span class="toc-text">并查集进一步优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">6.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">图的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">6.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E7%89%B9%E6%AE%8A%E5%BD%A2%E6%80%81%E7%9A%84%E5%9B%BE"><span class="toc-number">6.1.2.</span> <span class="toc-text">几种特殊形态的图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text">图的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="toc-number">6.2.1.</span> <span class="toc-text">邻接矩阵法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95"><span class="toc-number">6.2.2.</span> <span class="toc-text">邻接表法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E3%80%81%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%9A"><span class="toc-number">6.2.3.</span> <span class="toc-text">邻接矩阵、邻接表存储有向图：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.4.</span> <span class="toc-text">基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">6.3.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88BFS%EF%BC%89"><span class="toc-number">6.3.1.</span> <span class="toc-text">图的广度优先遍历（BFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%88DFS%EF%BC%89"><span class="toc-number">6.3.2.</span> <span class="toc-text">图的深度优先遍历（DFS）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E2%BC%A9%E2%BD%A3%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98"><span class="toc-number">6.4.</span> <span class="toc-text">最⼩⽣成树问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim-%E7%AE%97%E6%B3%95%EF%BC%88%E6%99%AE%E2%BE%A5%E5%A7%86%EF%BC%89"><span class="toc-number">6.4.1.</span> <span class="toc-text">Prim 算法（普⾥姆）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal-%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%EF%BC%89"><span class="toc-number">6.4.2.</span> <span class="toc-text">Kruskal 算法（克鲁斯卡尔）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.5.</span> <span class="toc-text">最短路径问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BFS%E2%80%94%E6%97%A0%E6%9D%83%E5%9B%BE"><span class="toc-number">6.5.1.</span> <span class="toc-text">BFS—无权图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D%C4%B3kstra%E7%AE%97%E6%B3%95-%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8"><span class="toc-number">6.5.2.</span> <span class="toc-text">Dĳkstra算法 ——通用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%9A%E7%94%A8"><span class="toc-number">6.5.3.</span> <span class="toc-text">Floyd算法——通用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%EF%BC%88DAG%EF%BC%89"><span class="toc-number">6.6.</span> <span class="toc-text">有向无环图（DAG）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E2%BD%86%E7%8E%AF%E5%9B%BE-%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">6.6.1.</span> <span class="toc-text">有向⽆环图  描述表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">6.6.2.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-number">6.6.2.1.</span> <span class="toc-text">**拓扑排序的实现： **</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88DFS%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">6.6.2.2.</span> <span class="toc-text">逆拓扑排序的实现（DFS算法）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">6.6.3.</span> <span class="toc-text">关键路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">7.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">查找的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%9F%A5%E6%89%BE"><span class="toc-number">7.2.</span> <span class="toc-text">常见查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">7.2.1.</span> <span class="toc-text">顺序查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">7.2.2.</span> <span class="toc-text">折半查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="toc-number">7.2.3.</span> <span class="toc-text">分块查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE"><span class="toc-number">7.3.</span> <span class="toc-text">散列查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88Hash-Table%EF%BC%89"><span class="toc-number">7.3.1.</span> <span class="toc-text">散列表（Hash Table）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.2.</span> <span class="toc-text">常见散列函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE-1"><span class="toc-number">7.3.3.</span> <span class="toc-text">散列查找</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">8.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">排序的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">8.2.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">8.2.1.</span> <span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">8.2.2.</span> <span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.</span> <span class="toc-text">交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.2.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">8.4.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">8.4.1.</span> <span class="toc-text">简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">8.4.2.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-number">8.4.3.</span> <span class="toc-text">堆的插入和删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">8.5.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">8.6.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">8.7.</span> <span class="toc-text">外部排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F-1"><span class="toc-number">8.7.1.</span> <span class="toc-text">外部排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A5%E8%80%85%E6%A0%91"><span class="toc-number">8.7.2.</span> <span class="toc-text">败者树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">8.7.3.</span> <span class="toc-text">置换选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="toc-number">8.7.4.</span> <span class="toc-text">最佳归并树</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/22/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%951/" title="图片测试1">图片测试1</a><time datetime="2023-07-22T13:02:50.000Z" title="发表于 2023-07-22 21:02:50">2023-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">数据结构</a><time datetime="2023-07-22T12:57:50.000Z" title="发表于 2023-07-22 20:57:50">2023-07-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/05/04/hello-world/" title="Hello World">Hello World</a><time datetime="2023-05-04T04:44:42.349Z" title="发表于 2023-05-04 12:44:42">2023-05-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Oreges</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>